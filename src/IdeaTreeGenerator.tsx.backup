/// <reference types="vite/client" />
import React, { useState, useRef, useEffect } from 'react';
import { Edit2, Trash2, Zap, X, Lightbulb, ArrowRight, ArrowLeft, Check, Maximize2, Star, Plus, Sparkles, RotateCcw, AlertCircle, ChevronRight, Home, LayoutGrid } from 'lucide-react';

// API URL: Use environment variable or fallback to localhost for development
// In Vercel deployment, use relative path '/api/anthropic' which maps to Vercel Functions
const API_URL = (import.meta as any).env?.VITE_API_URL || ((import.meta as any).env?.DEV ? 'http://localhost:3001/api/anthropic' : '/api/anthropic');

function CircleNode({ node, pos, size, color, isSelected, onSelect, onMouseDown, onClick = null }) {
  const [isHovered, setIsHovered] = useState(false);
  const [tooltipPosition, setTooltipPosition] = useState<'right' | 'left' | 'top' | 'bottom'>('right');
  const tooltipRef = useRef<HTMLDivElement>(null);
  const nodeRef = useRef<HTMLDivElement>(null);

  const updateTooltipPosition = () => {
    if (!nodeRef.current) return;

    const nodeRect = nodeRef.current.getBoundingClientRect();
    // Find the structure graph container or overflow container
    const container = nodeRef.current.closest('.overflow-auto, #structure-graph-container') ||
      document.getElementById('structure-graph-container')?.closest('.overflow-auto');
    const containerRect = container?.getBoundingClientRect();

    // Get actual tooltip dimensions if available
    const tooltipWidth = tooltipRef.current?.getBoundingClientRect().width || 250;
    const tooltipHeight = tooltipRef.current?.getBoundingClientRect().height || 60;
    const margin = 10;

    if (!containerRect) {
      // Fallback: use viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      const spaceRight = viewportWidth - nodeRect.right - margin;
      const spaceLeft = nodeRect.left - margin;
      const spaceBottom = viewportHeight - nodeRect.bottom - margin;
      const spaceTop = nodeRect.top - margin;

      if (spaceRight >= tooltipWidth) {
        setTooltipPosition('right');
      } else if (spaceLeft >= tooltipWidth) {
        setTooltipPosition('left');
      } else if (spaceBottom >= tooltipHeight) {
        setTooltipPosition('bottom');
      } else if (spaceTop >= tooltipHeight) {
        setTooltipPosition('top');
      } else {
        setTooltipPosition('right');
      }
      return;
    }

    // Check available space in each direction
    const spaceRight = containerRect.right - nodeRect.right - margin;
    const spaceLeft = nodeRect.left - containerRect.left - margin;
    const spaceBottom = containerRect.bottom - nodeRect.bottom - margin;
    const spaceTop = nodeRect.top - containerRect.top - margin;

    // Determine best position
    if (spaceRight >= tooltipWidth) {
      setTooltipPosition('right');
    } else if (spaceLeft >= tooltipWidth) {
      setTooltipPosition('left');
    } else if (spaceBottom >= tooltipHeight) {
      setTooltipPosition('bottom');
    } else if (spaceTop >= tooltipHeight) {
      setTooltipPosition('top');
    } else {
      // Default to right but will be constrained by max-width
      setTooltipPosition('right');
    }
  };

  // Recalculate position when tooltip is rendered
  useEffect(() => {
    if (isHovered && tooltipRef.current) {
      updateTooltipPosition();
    }
  }, [isHovered]);

  return (
    <div
      ref={nodeRef}
      className="absolute"
      style={{
        left: `${pos.x - size / 2}px`,
        top: `${pos.y - size / 2}px`,
        width: `${size}px`,
        height: `${size}px`,
        zIndex: isHovered || isSelected ? 10 : 2,
        cursor: onMouseDown ? 'move' : 'pointer'
      }}
      onMouseEnter={() => {
        setIsHovered(true);
        // Small delay to ensure tooltip is rendered before calculating position
        setTimeout(updateTooltipPosition, 10);
      }}
      onMouseLeave={() => setIsHovered(false)}
      onMouseDown={(e) => {
        if (onMouseDown) {
          onMouseDown(e, node);
        }
      }}
      onClick={(e) => {
        // If onClick prop is provided, use it (for structure mode)
        if (onClick) {
          onClick(e);
        } else if (onSelect && !onMouseDown) {
          // Otherwise, use onSelect if no onMouseDown
          onSelect();
        }
      }}
    >
      <div
        className="w-full h-full rounded-full cursor-pointer transition-all"
        style={{
          backgroundColor: color,
          transform: isHovered ? 'scale(1.5)' : 'scale(1)',
          boxShadow: isSelected ? '0 0 0 3px rgba(59, 130, 246, 0.5)' : 'none'
        }}
      />
      {isHovered && (
        <div
          ref={tooltipRef}
          className={`absolute bg-white px-3 py-2 rounded-lg shadow-lg border border-gray-200 text-sm z-20 break-words ${tooltipPosition === 'right' ? 'left-full ml-2 top-1/2 -translate-y-1/2' :
            tooltipPosition === 'left' ? 'right-full mr-2 top-1/2 -translate-y-1/2' :
              tooltipPosition === 'bottom' ? 'top-full mt-2 left-1/2 -translate-x-1/2' :
                'bottom-full mb-2 left-1/2 -translate-x-1/2'
            }`}
          style={{
            wordBreak: 'break-word',
            whiteSpace: 'normal',
            width: '200px',
            maxHeight: 'none',
            overflowY: 'visible',
            lineHeight: '1.5'
          }}
        >
          {node.title || node.text}
        </div>
      )}
    </div>
  );
}

export default function IdeaTreeGenerator() {
  const [mode, setMode] = useState('exploration');
  const [inputValue, setInputValue] = useState('');
  const [landingInputValue, setLandingInputValue] = useState(''); // Landing page input
  const [nodes, setNodes] = useState([]);
  const [reflections, setReflections] = useState([]);
  const [selectedNode, setSelectedNode] = useState(null);
  const [editingNode, setEditingNode] = useState(null);
  const [editValue, setEditValue] = useState('');
  const [loading, setLoading] = useState(false);
  const [focusedNode, setFocusedNode] = useState(null);
  const [creativityHistory, setCreativityHistory] = useState([]);
  const [currentPage, setCurrentPage] = useState('main'); // 'main' or 'report'
  const [activeTab, setActiveTab] = useState('overview'); // 'overview' or 'timeline'
  const [editCount, setEditCount] = useState(0);
  const [aiGenerationCount, setAiGenerationCount] = useState(0);
  const [eventHistory, setEventHistory] = useState([]); // Track all events for semantic scoring
  const [selectedForStructure, setSelectedForStructure] = useState(new Set());
  const [hierarchyAnalysis, setHierarchyAnalysis] = useState(null);
  const [analyzingStructure, setAnalyzingStructure] = useState(false);
  const [structureReflections, setStructureReflections] = useState([]);
  const [focusedReflection, setFocusedReflection] = useState(null);
  const [expandedReflectionId, setExpandedReflectionId] = useState(null); // Track which reflection is expanded
  const [isReflectionSidebarOpen, setIsReflectionSidebarOpen] = useState(true); // Control reflection sidebar visibility
  const [isShiftPressed, setIsShiftPressed] = useState(false); // Track Shift key state
  const [draggingNode, setDraggingNode] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [mouseDownPos, setMouseDownPos] = useState({ x: 0, y: 0 });
  const [structureGridPositions, setStructureGridPositions] = useState({});
  const [nodeInitialPosition, setNodeInitialPosition] = useState<{ impact: number; feasibility: number } | null>(null);
  const [isPanning, setIsPanning] = useState(false);
  const [hoveredPointIndex, setHoveredPointIndex] = useState<number | null>(null);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [isSpacePressed, setIsSpacePressed] = useState(false);
  const [selectedStructureNode, setSelectedStructureNode] = useState(null);
  const [structureSelectedNodeIds, setStructureSelectedNodeIds] = useState(new Set()); // Store node IDs used for structure analysis
  const [currentStep, setCurrentStep] = useState(1); // Track current exploration step
  const [designTopic, setDesignTopic] = useState(''); // Store the initial design topic
  const [topicNodeId, setTopicNodeId] = useState(null); // Store the TOPIC node ID
  const [hoveredNodeId, setHoveredNodeId] = useState(null); // Track which node is hovered
  const [addNodeModal, setAddNodeModal] = useState(null); // Track which node's add button was clicked (node ID)
  const [addNodeText, setAddNodeText] = useState(''); // Text input for new node
  const nodeRefs = useRef({});
  const reflectionRefs = useRef({});
  const [animatingNodes, setAnimatingNodes] = useState(new Set()); // Track nodes that are animating

  // Helper function to add nodes with sequential animation
  const addNodesWithAnimation = (newNodes, delay = 300) => {
    newNodes.forEach((node, index) => {
      setTimeout(() => {
        setNodes(prev => {
          // Check if node already exists
          if (prev.find(n => n.id === node.id)) return prev;

          // Add node with animating flag
          const nodeWithAnimation = { ...node, isAnimating: true };
          const updated = [...prev, nodeWithAnimation];

          // Remove animating flag after animation completes
          setTimeout(() => {
            setNodes(current => current.map(n =>
              n.id === node.id ? { ...n, isAnimating: false } : n
            ));
            setAnimatingNodes(prev => {
              const next = new Set(prev);
              next.delete(node.id);
              return next;
            });
          }, 600); // Match animation duration

          setAnimatingNodes(prev => new Set(prev).add(node.id));
          return updated;
        });
      }, index * delay);
    });
  };

  // Check if we should show landing page (no nodes exist yet)
  const showLandingPage = nodes.length === 0 && !loading;

  useEffect(() => {
    const saved = localStorage.getItem('ideaTreeData');
    if (saved) {
      try {
        const data = JSON.parse(saved);
        setNodes(data.nodes || []);
        setReflections(data.reflections || []);
        setCreativityHistory(data.creativityHistory || []);
        setEditCount(data.editCount || 0);
        setAiGenerationCount(data.aiGenerationCount || 0);
        setHierarchyAnalysis(data.hierarchyAnalysis || null);
        setStructureReflections(data.structureReflections || []);
        setDesignTopic(data.designTopic || '');
        setTopicNodeId(data.topicNodeId || null);
        // Restore structure selected node IDs if saved
        if (data.structureSelectedNodeIds && Array.isArray(data.structureSelectedNodeIds)) {
          setStructureSelectedNodeIds(new Set(data.structureSelectedNodeIds));
        } else if (data.hierarchyAnalysis && data.hierarchyAnalysis.analysis) {
          // Fallback: restore from hierarchyAnalysis if structureSelectedNodeIds not saved
          const nodeIds = new Set(data.hierarchyAnalysis.analysis.map(a => a.nodeId));
          setStructureSelectedNodeIds(nodeIds);
        } else {
          setStructureSelectedNodeIds(new Set());
        }
        // Restore structure grid positions if saved
        if (data.structureGridPositions && typeof data.structureGridPositions === 'object') {
          setStructureGridPositions(data.structureGridPositions);
        }

        // Determine current step from nodes
        if (data.nodes && data.nodes.length > 0) {
          const maxStep = Math.max(...data.nodes.map(n => n.step || 1));
          setCurrentStep(Math.max(1, Math.min(4, maxStep + 1))); // Next step to work on
        } else {
          setCurrentStep(data.currentStep || 1);
        }
      } catch (e) {
        console.error('Failed to load saved data:', e);
      }
    }

    // Keyboard event listeners for space bar panning and Shift key
    const handleKeyDown = (e) => {
      if (e.code === 'Space' && !e.repeat && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
        e.preventDefault();
        setIsSpacePressed(true);
      }
      if (e.key === 'Shift' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        setIsShiftPressed(true);
      }
    };

    const handleKeyUp = (e) => {
      if (e.code === 'Space') {
        setIsSpacePressed(false);
        setIsPanning(false);
      }
      if (e.key === 'Shift' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        setIsShiftPressed(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // State to force re-render when returning to structure mode
  const [structureModeKey, setStructureModeKey] = useState(0);

  // Effect to force position recalculation when returning to structure mode
  // This ensures positions are recalculated after DOM is fully rendered
  useEffect(() => {
    if (mode === 'structure' && hierarchyAnalysis) {
      // Use a key-based approach to force re-render after DOM is ready
      const timeoutId = setTimeout(() => {
        // Increment key to force re-render of structure mode components
        setStructureModeKey(prev => prev + 1);
      }, 200); // Increased delay to ensure DOM is fully ready

      return () => clearTimeout(timeoutId);
    }
  }, [mode, hierarchyAnalysis]); // Run when mode or hierarchyAnalysis changes

  useEffect(() => {
    const dataToSave = {
      nodes,
      reflections,
      creativityHistory,
      editCount,
      aiGenerationCount,
      hierarchyAnalysis,
      structureReflections,
      currentStep,
      designTopic,
      topicNodeId,
      structureSelectedNodeIds: Array.from(structureSelectedNodeIds),
      structureGridPositions
    };
    localStorage.setItem('ideaTreeData', JSON.stringify(dataToSave));
  }, [nodes, reflections, creativityHistory, editCount, aiGenerationCount, hierarchyAnalysis, structureReflections, currentStep, designTopic, topicNodeId, structureSelectedNodeIds]);

  // ============================================================================
  // NEW SEMANTIC SPACE FRAMEWORK
  // Based on CSV: Event Tracking _ Criteria - Criteria.csv
  // ============================================================================

  // Calculate semantic scores for different event types
  const calculateSemanticScores = (eventType, actor, eventData) => {
    const scores = {
      semantic_generative_score: 0,
      semantic_blending_score: 0,
      semantic_reframing_score: 0,
      semantic_evaluation_score: 0,
      semantic_constraint_score: 0,
      semantic_domain_score: 0,
      semantic_input_score: 0,
      semantic_evaluation_delete_score: 0,
      semantic_evaluation_selection_score: 0,
      semantic_evaluation_move_score_small: 0,
      semantic_evaluation_move_score_big: 0
    };

    switch (eventType) {
      case 'Initial Input':
        // semantic_input_score: 0 = minimal; 1 = basic task; 2 = problem with context; 3 = complete brief
        const inputLength = (eventData.raw_content || '').length;
        if (inputLength < 20) scores.semantic_input_score = 0;
        else if (inputLength < 50) scores.semantic_input_score = 1;
        else if (inputLength < 150) scores.semantic_input_score = 2;
        else scores.semantic_input_score = 3;
        break;

      case 'Create Node':
        if (actor === 'AI') {
          // AI generating nodes - always expands semantic space
          const nodeCount = eventData.node_count || 1;
          const content = (eventData.new_content || '').toLowerCase();

          // 1. Generative Expansion: ALWAYS present when nodes are created
          if (nodeCount === 1) scores.semantic_generative_score = 1; // adds 1 small new idea
          else if (nodeCount <= 3) scores.semantic_generative_score = 2; // adds 2-3 distinct ideas
          else scores.semantic_generative_score = 3; // adds >3 diverse ideas

          // 2. Conceptual Blending: Multiple nodes = conceptual connections
          if (eventData.node_ids_involved && eventData.node_ids_involved.length > 1) {
            if (eventData.node_ids_involved.length >= 3) {
              scores.semantic_blending_score = 3; // strong conceptual fusion
            } else {
              scores.semantic_blending_score = 2; // clear cross-domain analogy
            }
          } else if (nodeCount > 1) {
            scores.semantic_blending_score = 1; // superficial linkage (multiple nodes = some blending)
          }
          // Single node: no blending (0 is correct)

          // 3. Reframing: New nodes usually introduce new perspectives
          if (eventData.shifts_direction) {
            scores.semantic_reframing_score = 2; // clear shift in perspective
          } else if (nodeCount > 1) {
            scores.semantic_reframing_score = 1; // minor adjustment (multiple perspectives)
          } else {
            // Single node creation still adds perspective, give minimal score
            scores.semantic_reframing_score = 1; // minor adjustment
          }

          // 4. Evaluation: Check for evaluative language or insights
          const evaluativeKeywords = ['should', 'must', 'important', 'critical', 'key', 'essential', 'consider', 'evaluate', 'need', 'priority', 'insight', 'observe', 'notice', 'pattern'];
          const evaluationCount = evaluativeKeywords.filter(kw => content.includes(kw)).length;
          if (evaluationCount >= 3) {
            scores.semantic_evaluation_score = 2; // explicit critique
          } else if (evaluationCount >= 1) {
            scores.semantic_evaluation_score = 1; // light preference/judgment
          }
          // No keywords: no evaluation (0 is correct)

          // 5. Constraint Setting: Check for constraints or limitations
          const constraintKeywords = ['constraint', 'limit', 'must', 'require', 'only', 'specific', 'within', 'bound', 'restrict', 'focus', 'narrow', 'scope'];
          const constraintCount = constraintKeywords.filter(kw => content.includes(kw)).length;
          if (constraintCount >= 2) {
            scores.semantic_constraint_score = 2; // moderate narrowing
          } else if (constraintCount >= 1) {
            scores.semantic_constraint_score = 1; // small constraint
          }
          // No keywords: no constraint (0 is correct)

          // 6. Domain Knowledge: Based on content detail - ALWAYS give score if content exists
          // AI generating nodes always adds some domain knowledge
          const contentLength = eventData.content_length || (eventData.new_content || '').length;
          if (contentLength > 200) {
            scores.semantic_domain_score = 3; // deep professional knowledge
          } else if (contentLength > 100) {
            scores.semantic_domain_score = 2; // moderate contextualization
          } else if (contentLength > 20) {
            scores.semantic_domain_score = 1; // light contextual detail
          }
          // Give at least 1 point if there's any content at all (AI always adds some knowledge)
          if (contentLength > 0 && scores.semantic_domain_score === 0) {
            scores.semantic_domain_score = 1; // minimum: any content = light contextual detail
          }
        } else {
          // Human manually creating node
          scores.semantic_generative_score = 1; // adds 1 small new idea
          // Human creation might also have domain knowledge
          const contentLength = (eventData.new_content || '').length;
          if (contentLength > 30) {
            scores.semantic_domain_score = 1; // light contextual detail
          }
        }
        break;

      case 'Edit Node':
        if (actor === 'HUMAN') {
          // Check if edit shifts direction (reframing)
          const oldText = eventData.raw_content || '';
          const newText = eventData.new_content || '';
          const similarity = calculateTextSimilarity(oldText, newText);
          if (similarity < 0.3) {
            scores.semantic_reframing_score = 3; // full redefinition
          } else if (similarity < 0.6) {
            scores.semantic_reframing_score = 2; // clear shift
          } else if (similarity < 0.8) {
            scores.semantic_reframing_score = 1; // minor adjustment
          }

          // Check for constraint setting
          const constraintKeywords = ['constraint', 'limit', 'must', 'require', 'only', 'specific'];
          const hasConstraint = constraintKeywords.some(kw => newText.toLowerCase().includes(kw));
          if (hasConstraint) {
            scores.semantic_constraint_score = 2; // moderate narrowing
          }

          // Domain knowledge
          if (newText.length > oldText.length * 1.5) {
            scores.semantic_domain_score = 2; // moderate contextualization
          }
        }
        break;

      case 'Delete Node':
        if (actor === 'HUMAN') {
          const deleteCount = eventData.delete_count || 1;
          if (deleteCount === 1) scores.semantic_evaluation_delete_score = 1;
          else if (deleteCount <= 3) scores.semantic_evaluation_delete_score = 2;
          else scores.semantic_evaluation_delete_score = 3;

          scores.semantic_evaluation_score = scores.semantic_evaluation_delete_score;
        }
        break;

      case 'Move Node (within-boundary)':
        if (actor === 'HUMAN') {
          // Calculate move distance to determine score (1-3) per CSV criteria
          const moveDistance = eventData.move_distance || 0;
          if (moveDistance > 4) {
            scores.semantic_evaluation_move_score_small = 3; // large repositioning within quadrant
          } else if (moveDistance > 2) {
            scores.semantic_evaluation_move_score_small = 2; // noticeable repositioning
          } else {
            scores.semantic_evaluation_move_score_small = 1; // small repositioning within quadrant
          }
          scores.semantic_evaluation_score = scores.semantic_evaluation_move_score_small;
        }
        break;

      case 'Move Node (cross-boundary)':
        if (actor === 'HUMAN') {
          // Check if this is a multiple cross-quadrant move (3 points) or single (2 points)
          // Count previous cross-boundary moves for this node in recent events
          const recentCrossBoundaryMoves = eventHistory.filter(e =>
            e.actor === 'HUMAN' &&
            e.event_type === 'Move Node (cross-boundary)' &&
            e.node_id === eventData.node_id
          ).length;

          if (recentCrossBoundaryMoves >= 1) {
            // Multiple cross-quadrant moves or direction-level reframing
            scores.semantic_evaluation_move_score_big = 3;
            scores.semantic_reframing_score = 3; // full redefinition (direction-level reframing)
          } else {
            // Single move across quadrants
            scores.semantic_evaluation_move_score_big = 2;
            scores.semantic_reframing_score = 2; // clear shift in perspective
          }
          scores.semantic_evaluation_score = scores.semantic_evaluation_move_score_big;
        }
        break;

      case 'Select Nodes for Structure':
        if (actor === 'HUMAN') {
          // CSV criteria: 1 = select 1 node; 2 = select 2-3 nodes; 3 = select multiple nodes (strong prioritization)
          const selectionCount = eventData.selection_count || 1;
          if (selectionCount >= 4) {
            scores.semantic_evaluation_selection_score = 3; // select multiple nodes (strong prioritization)
          } else if (selectionCount >= 2) {
            scores.semantic_evaluation_selection_score = 2; // select 2-3 nodes
          } else {
            scores.semantic_evaluation_selection_score = 1; // select 1 node
          }
          scores.semantic_evaluation_score = scores.semantic_evaluation_selection_score;
        }
        break;
    }

    // Calculate total semantic score
    const semantic_total_score =
      scores.semantic_generative_score +
      scores.semantic_blending_score +
      scores.semantic_reframing_score +
      scores.semantic_evaluation_score +
      scores.semantic_constraint_score +
      scores.semantic_domain_score;

    return {
      ...scores,
      semantic_total_score
    };
  };

  // Helper function to calculate text similarity
  const calculateTextSimilarity = (text1, text2) => {
    if (!text1 || !text2) return 0;
    const words1 = new Set(text1.toLowerCase().split(/\s+/));
    const words2 = new Set(text2.toLowerCase().split(/\s+/));
    const intersection = new Set([...words1].filter(w => words2.has(w)));
    const union = new Set([...words1, ...words2]);
    return union.size > 0 ? intersection.size / union.size : 0;
  };

  // Track an event and calculate semantic scores
  const trackEvent = (eventType, actor, eventData) => {
    const event = {
      event_id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      actor: actor, // 'HUMAN' or 'AI'
      mode: mode, // 'exploration' or 'structure'
      event_type: eventType,
      raw_content: eventData.raw_content || null,
      new_content: eventData.new_content || null,
      node_id: eventData.node_id || null,
      node_ids_involved: eventData.node_ids_involved || null,
      timestamp: new Date().toISOString(),
      ...calculateSemanticScores(eventType, actor, eventData)
    };

    // Calculate human and AI totals
    const humanEvents = eventHistory.filter(e => e.actor === 'HUMAN');
    const aiEvents = eventHistory.filter(e => e.actor === 'AI');

    const humanScoreTotal = [...humanEvents, ...(actor === 'HUMAN' ? [event] : [])]
      .reduce((sum, e) => sum + ((e as any).semantic_total_score || 0), 0);
    const aiScoreTotal = [...aiEvents, ...(actor === 'AI' ? [event] : [])]
      .reduce((sum, e) => sum + ((e as any).semantic_total_score || 0), 0);

    const totalScore = humanScoreTotal + aiScoreTotal;
    (event as any).human_score_total = humanScoreTotal;
    (event as any).ai_score_total = aiScoreTotal;
    (event as any).curve_human_ratio = totalScore > 0 ? humanScoreTotal / totalScore : 0;
    (event as any).curve_ai_ratio = totalScore > 0 ? aiScoreTotal / totalScore : 0;

    setEventHistory(prev => [...prev, event]);
    return event;
  };

  // Calculate Creativity Index using NEW Semantic Space Framework
  const calculateCreativityIndex = () => {
    if (eventHistory.length === 0) {
      // Fallback for backward compatibility
      return { creativity: 0, dependency: 0 };
    }

    // Calculate totals from event history
    const humanEvents = eventHistory.filter(e => e.actor === 'HUMAN');
    const aiEvents = eventHistory.filter(e => e.actor === 'AI');

    const humanScoreTotal = humanEvents.reduce((sum, e) => sum + ((e as any).semantic_total_score || 0), 0);
    const aiScoreTotal = aiEvents.reduce((sum, e) => sum + ((e as any).semantic_total_score || 0), 0);
    const totalScore = humanScoreTotal + aiScoreTotal;

    // Normalize to 0-1 range (assuming max possible score per event is 18 = 6 dimensions * 3)
    const maxPossibleScore = eventHistory.length * 18;
    const normalizedHumanScore = maxPossibleScore > 0 ? humanScoreTotal / maxPossibleScore : 0;
    const normalizedAiScore = maxPossibleScore > 0 ? aiScoreTotal / maxPossibleScore : 0;

    // Creativity = Human contribution ratio (higher human contribution = higher creativity)
    // Dependency = AI contribution ratio (higher AI contribution = higher dependency)
    const creativity = totalScore > 0 ? humanScoreTotal / totalScore : 0;
    const dependency = totalScore > 0 ? aiScoreTotal / totalScore : 0;

    return {
      creativity: Math.max(0, Math.min(1, creativity)),
      dependency: Math.max(0, Math.min(1, dependency)),
      human_score_total: humanScoreTotal,
      ai_score_total: aiScoreTotal,
      curve_human_ratio: creativity,
      curve_ai_ratio: dependency,
      // Keep old fields for backward compatibility
      fluency: normalizedHumanScore,
      flexibility: normalizedAiScore,
      originality: creativity,
      elaboration: dependency
    };
  };

  // Legacy function for backward compatibility
  const calculateCreativityGravity = () => {
    const { creativity } = calculateCreativityIndex();
    return creativity;
  };

  // Extract keyword from text (fallback for nodes without keyword)
  const extractKeyword = (text) => {
    if (!text) return '';
    // Take first 2-4 words as keyword
    const words = text.trim().split(/\s+/);
    if (words.length <= 4) return text;
    return words.slice(0, 3).join(' ');
  };

  // Get text to display based on node size (to prevent overflow)
  const getDisplayText = (text, nodeSize, isSelected) => {
    if (!text) return '';

    // ÎÖ∏Îìú ÌÅ¨Í∏∞Ïóê Îî∞Îùº ÌëúÏãúÌï† ÏµúÎåÄ Í∏ÄÏûê Ïàò Í≤∞Ï†ï
    // ÏûëÏùÄ ÎÖ∏ÎìúÏùºÏàòÎ°ù Îçî ÏßßÍ≤å ÏûêÎ•¥Í∏∞
    let maxLength;
    if (nodeSize <= 80) {
      // insight, opportunity ÎÖ∏Îìú
      maxLength = isSelected ? 30 : 12;
    } else if (nodeSize <= 100) {
      // sub ÎÖ∏Îìú
      maxLength = isSelected ? 40 : 15;
    } else if (nodeSize <= 120) {
      // main ÎÖ∏Îìú
      maxLength = isSelected ? 50 : 20;
    } else {
      // topic ÎÖ∏Îìú
      maxLength = isSelected ? 60 : 25;
    }

    if (text.length <= maxLength) return text;
    return text.slice(0, maxLength) + '...';
  };

  // Handle Start Exploration from Landing Page
  const handleStartExploration = async () => {
    if (!landingInputValue.trim()) {
      alert('Please enter your idea first.');
      return;
    }

    const topicText = landingInputValue.trim();
    setDesignTopic(topicText);
    setLoading(true);

    try {
      // First, create TOPIC node
      const topicNodeId = Date.now();
      const topicNode = {
        id: topicNodeId,
        text: topicText,
        keyword: extractKeyword(topicText),
        type: 'topic',
        step: 0,
        category: 'TOPIC',
        parentId: null,
        x: 600, // Center of canvas
        y: 100, // Top area
        level: 0,
        manuallyPositioned: false
      };

      setNodes([topicNode]);
      setTopicNodeId(topicNodeId);

      // Track Initial Input event
      trackEvent('Initial Input', 'HUMAN', {
        raw_content: topicText,
        node_id: topicNodeId.toString()
      });

      // Then generate Step 1 nodes (Context, User, Task, Goal) as children of TOPIC
      await generateStep1ProblemFraming(topicText, topicNodeId);
    } catch (err) {
      console.error('Start exploration error:', err);
      alert('An error occurred while starting exploration.');
      setLoading(false);
    }
  };

  // Step 1: Problem Framing - 4 main nodes (Context, User, Task, Goal) - ALL AT ONCE
  const generateStep1ProblemFraming = async (designTopic, parentTopicId = null) => {
    setDesignTopic(designTopic);
    try {
      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2000,
          messages: [
            {
              role: "user",
              content: `Given a design topic, generate 4 problem-framing nodes following this structure:

Design Topic: "${designTopic}"

üî∂ STEP 1: PROBLEM FRAMING

üü¢ GOAL:
Output 4 main problem-framing nodes:
- Context: Where does the problem occur?
- User: Who is involved and what characterizes them?
- Task: What actions, behaviors, or processes are relevant?
- Goal: What outcome or value is the user pursuing?

üü° CONSTRAINTS:
- Output only the 4 node titles with descriptions
- No sub-details, no insights, no opinions
- Do NOT include any opportunities or solutions
- Each node title should be a concise phrase (5-10 words)
- Each description should provide more detail (1-3 sentences)

üü† FORMAT (MUST FOLLOW EXACTLY):
Respond ONLY in JSON format:
{
  "nodes": [
    { "category": "Context", "title": "...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." },
    { "category": "User", "title": "...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." },
    { "category": "Task", "title": "...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." },
    { "category": "Goal", "title": "...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." }
  ]
}

Note: 
- "title": Short, concise phrase (5-10 words) for display on the node
- "description": Detailed explanation (1-3 sentences) shown when node is clicked
- "keyword" should be a concise 2‚Äì5 word phrase capturing the main meaning.
- "critic" (optional): Must be only ONE sentence under 18 words, and must be a short challenging question from a different perspective that provokes reflection (must end with "?"). Example critic patterns: questioning hidden causes, challenging assumptions, reconsidering boundaries. If no meaningful critic applies, omit this field.
- "advice" (optional): Must be only ONE sentence under 18 words, and must be a brief strategy-oriented suggestion that deepens or expands the idea. Example advice patterns: creative reframing strategies, gamification patterns, exploring cross-modal cues. Do not include solutions or implementation details. If no meaningful advice applies, omit this field.`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      const newAiCount = aiGenerationCount + 1;
      setAiGenerationCount(newAiCount);

      const newNodes = parsed.nodes.map((nodeObj, index) => {
        const nodeId = Date.now() + index * 10000 + Math.floor(Math.random() * 1000);

        // Create reflections if provided (critic, advice)
        const reflectionTypes = [
          { type: 'critic', data: nodeObj.critic },
          { type: 'advice', data: nodeObj.advice }
        ];

        reflectionTypes.forEach((refType, idx) => {
          if (refType.data && typeof refType.data === 'string' && refType.data.trim()) {
            setReflections(prev => [{
              id: nodeId + 10000 + idx,
              nodeId: nodeId,
              topic: nodeObj.title || nodeObj.text, // Keep node text for reference
              title: refType.data.trim(), // Use the reflection text as title
              content: refType.data.trim(), // Same content for display
              type: refType.type
            }, ...prev]);
          }
        });

        // Calculate initial position with collision detection during creation only
        const parentNode = nodes.find(n => n.id === parentTopicId);
        const parentPos = parentNode ? getNodePosition(parentNode) : { x: 400, y: 200 };
        const spacing = 150;
        const totalNodes = parsed.nodes.length;
        const centerOffset = (totalNodes - 1) * spacing / 2;
        const baseX = parentPos.x + (index * spacing) - centerOffset;
        const baseY = parentPos.y + 120;

        // Apply collision detection only during initial creation
        const nodeSize = 120; // main node size
        const allExistingNodes = nodes.filter(n => n.id !== nodeId);
        const adjustedPos = findNonCollidingPosition({ x: baseX, y: baseY }, nodeSize, allExistingNodes, nodeId);
        const initialX = adjustedPos.x;
        const initialY = adjustedPos.y;

        return {
          id: nodeId,
          title: nodeObj.title || nodeObj.text || '',
          description: nodeObj.description || '',
          text: nodeObj.text || nodeObj.title || '', // For backward compatibility
          keyword: nodeObj.keyword || extractKeyword(nodeObj.title || nodeObj.text || ''),
          type: 'main',
          step: 1,
          category: nodeObj.category,
          parentId: parentTopicId, // Connect to TOPIC node
          x: initialX,
          y: initialY,
          level: 1,
          manuallyPositioned: false
        };
      });

      // Add nodes with sequential animation
      addNodesWithAnimation(newNodes, 300);
      setCurrentStep(2); // Move to step 2 after step 1 completion

      // Track Create Node event as a batch (all nodes together)
      // This allows proper calculation of node_count and blending scores
      if (newNodes.length > 0) {
        const nodeIds = newNodes.map(n => n.id.toString());
        const combinedContent = newNodes.map(n => n.text).join(' ');
        const avgContentLength = combinedContent.length / newNodes.length;

        trackEvent('Create Node', 'AI', {
          node_id: nodeIds[0], // First node ID
          node_ids_involved: nodeIds, // All node IDs for blending calculation
          new_content: combinedContent, // Combined content for analysis
          node_count: newNodes.length, // Actual count of nodes created
          shifts_direction: true, // Step 1 always shifts from topic
          content_length: avgContentLength
        });
      }

      const newMetrics = calculateCreativityIndex();
      setCreativityHistory(prev => [...prev, newMetrics]);
    } catch (err) {
      console.error('Step 1 generation error:', err);
      alert('An error occurred while generating problem framing nodes.');
    }
    setLoading(false);
  };

  // Step 2: Sub-node Expansion - Helper for multi-selection (returns nodes)
  const generateStep2SubNodesForMulti = async (parentNode) => {
    if (parentNode.type !== 'main' || parentNode.step !== 1) return [];

    // Check if already expanded
    const existingChildren = nodes.filter(n => n.parentId === parentNode.id || (n.parentIds && n.parentIds.includes(parentNode.id)));
    if (existingChildren.length > 0) return [];

    return await generateStep2SubNodesInternal(parentNode);
  };

  // Step 2: Sub-node Expansion - Internal function
  const generateStep2SubNodesInternal = async (parentNode) => {
    try {
      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2000,
          messages: [
            {
              role: "user",
              content: `Given a main problem-framing node, expand it into 1-3 concrete, specific sub-nodes (generate 1, 2, or 3 based on what makes sense).

Main Node: [${parentNode.category}] ${parentNode.text}

üî∂ STEP 2: SUB-NODE EXPANSION

üü¢ GOAL:
Expand the main node into 1-3 concrete, specific sub-nodes that help detail the space.

üü° CONSTRAINTS:
- Generate 1, 2, or 3 sub-nodes (choose the number that makes most sense)
- Sub-nodes must be grounded in real-world places, actors, actions, or goals
- Avoid abstract categories (e.g., "Public Space" ‚Üí ‚úò; "Hospital Waiting Room" ‚Üí ‚úî)
- Avoid including user pain points, opinions, or ideas
- Avoid jumping ahead to solutions
- Each sub-node should be specific and concrete (5-15 words)

üü† FORMAT:
Respond ONLY in JSON format:
{
  "subNodes": [
    { "title": "...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." },
    ... (1-3 items total)
  ]
}

Note: 
- "title": Short, concise phrase (5-15 words) displayed on the node
- "description": Detailed explanation (1-3 sentences) shown when node is clicked
- "keyword" should be a concise 2‚Äì5 word phrase capturing the main meaning.
- "critic" (optional): Must be only ONE sentence under 18 words, and must be a short challenging question from a different perspective that provokes reflection (must end with "?"). Example critic patterns: questioning hidden causes, challenging assumptions, reconsidering boundaries. If no meaningful critic applies, omit this field.
- "advice" (optional): Must be only ONE sentence under 18 words, and must be a brief strategy-oriented suggestion that deepens or expands the idea. Example advice patterns: creative reframing strategies, gamification patterns, exploring cross-modal cues. Do not include solutions or implementation details. If no meaningful advice applies, omit this field.`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      const newAiCount = aiGenerationCount + 1;
      setAiGenerationCount(newAiCount);

      // Get parent position (will be calculated by getNodePosition)
      const parentPos = getNodePosition(parentNode);
      const siblings = nodes.filter(n => n.parentId === parentNode.id);

      const newNodes = parsed.subNodes.map((subNodeObj, index) => {
        const nodeId = Date.now() + index * 10000 + Math.floor(Math.random() * 1000);

        // Create reflections if provided (critic, advice)
        const reflectionTypes = [
          { type: 'critic', data: subNodeObj.critic },
          { type: 'advice', data: subNodeObj.advice }
        ];

        reflectionTypes.forEach((refType, idx) => {
          if (refType.data && typeof refType.data === 'string' && refType.data.trim()) {
            setReflections(prev => [{
              id: nodeId + 10000 + idx,
              nodeId: nodeId,
              topic: subNodeObj.title || subNodeObj.text, // Keep node text for reference
              title: refType.data.trim(), // Use the reflection text as title
              content: refType.data.trim(), // Same content for display
              type: refType.type
            }, ...prev]);
          }
        });

        // Calculate initial position with collision detection during creation only
        const spacing = 130;
        const siblingCount = parsed.subNodes.length;
        const centerOffset = (siblingCount - 1) * spacing / 2;
        const baseX = parentPos.x + (index * spacing) - centerOffset;
        const baseY = parentPos.y + 120;

        // Apply collision detection only during initial creation
        const nodeSize = 100; // sub node size
        const allExistingNodes = nodes.filter(n => n.id !== nodeId);
        const adjustedPos = findNonCollidingPosition({ x: baseX, y: baseY }, nodeSize, allExistingNodes, nodeId);
        const initialX = adjustedPos.x;
        const initialY = adjustedPos.y;

        return {
          id: nodeId,
          title: subNodeObj.title || subNodeObj.text || '',
          description: subNodeObj.description || '',
          text: subNodeObj.text || subNodeObj.title || '', // For backward compatibility
          keyword: subNodeObj.keyword || extractKeyword(subNodeObj.title || subNodeObj.text || ''),
          type: 'sub',
          step: 2,
          category: parentNode.category,
          parentId: parentNode.id,
          x: initialX,
          y: initialY,
          level: 1,
          manuallyPositioned: false
        };
      });

      // Add nodes with sequential animation
      addNodesWithAnimation(newNodes, 300);
      setCurrentStep(3); // Move to step 3 after step 2 completion

      // Track Create Node event as a batch
      if (newNodes.length > 0) {
        const nodeIds = newNodes.map(n => n.id.toString());
        const combinedContent = newNodes.map(n => n.text).join(' ');
        const avgContentLength = combinedContent.length / newNodes.length;

        trackEvent('Create Node', 'AI', {
          node_id: nodeIds[0],
          node_ids_involved: nodeIds,
          new_content: combinedContent,
          node_count: newNodes.length,
          content_length: avgContentLength
        });
      }

      const newMetrics = calculateCreativityIndex();
      setCreativityHistory(prev => [...prev, newMetrics]);

      return newNodes;
    } catch (err) {
      console.error('Step 2 generation error:', err);
      alert('An error occurred while generating sub-nodes.');
      return [];
    }
  };

  // Step 2: Sub-node Expansion - Public function (for single selection)
  // Step 3: User Behavior Insights - Public function (for single selection)
  const generateStep3Insights = async (parentNode) => {
    // Allow both main (step 1) and sub (step 2) nodes to generate insights
    if ((parentNode.type !== 'main' && parentNode.type !== 'sub') || (parentNode.step !== 1 && parentNode.step !== 2)) return;

    // Check if already expanded
    const existingChildren = nodes.filter(n => n.parentId === parentNode.id);
    if (existingChildren.length > 0) return;

    setLoading(true);
    await generateStep3InsightsInternal(parentNode);
    setLoading(false);
  };

  const generateStep2SubNodes = async (parentNode) => {
    // This function is now deprecated - main nodes should generate insights directly
    // Keeping for backward compatibility but redirecting to insight generation
    if (parentNode.type === 'main' && parentNode.step === 1) {
      await generateStep3Insights(parentNode);
      return;
    }

    if (parentNode.type !== 'main' || parentNode.step !== 1) return;

    // Check if already expanded
    const existingChildren = nodes.filter(n => n.parentId === parentNode.id);
    if (existingChildren.length > 0) return;

    setLoading(true);
    await generateStep2SubNodesInternal(parentNode);
    setLoading(false);
  };

  // Step 3: User Behavior Insights - Helper for multi-selection (returns nodes)
  const generateStep3InsightsForMulti = async (parentNode) => {
    // Allow both main (step 1) and sub (step 2) nodes to generate insights
    if ((parentNode.type !== 'main' && parentNode.type !== 'sub') || (parentNode.step !== 1 && parentNode.step !== 2)) return [];

    const existingChildren = nodes.filter(n => n.parentId === parentNode.id || (n.parentIds && n.parentIds.includes(parentNode.id)));
    if (existingChildren.length > 0) return [];

    return await generateStep3InsightsInternal(parentNode);
  };

  // Step 3: User Behavior Insights - Internal function
  const generateStep3InsightsInternal = async (parentNode) => {
    try {
      // Determine if parent is main node (Context/Task/Goal/User) or sub node
      const isMainNode = parentNode.type === 'main' && parentNode.step === 1;
      const nodeLabel = isMainNode ? `Main node: [${parentNode.category}] ${parentNode.text}` : `Sub-node: [${parentNode.category}] ${parentNode.text}`;

      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2000,
          messages: [
            {
              role: "user",
              content: `Given a ${isMainNode ? 'main problem-framing node (Context, User, Task, or Goal)' : 'sub-node'}, generate 1-3 user behavior insights (generate 1, 2, or 3 based on what makes sense).

${nodeLabel}

üî∂ STEP 3: USER BEHAVIOR & PAIN POINT INSIGHTS

üü¢ GOAL:
Generate 1-3 user behavior insights for this sub-node. Each insight should describe a specific pattern or behavior that might occur in that sub-context. The insight should **imply** a breakdown, challenge, or pain point ‚Äî without directly proposing any solution or feature.

üü° CONSTRAINTS:
- Generate 1, 2, or 3 insights (choose the number that makes most sense)
- Must focus on observable user behavior (not opinions or vague emotions)
- Each insight must imply a problem, friction, or need
- Insights must be concise (10‚Äì18 words)
- Do NOT include any solution, technology, or feature
- Do NOT repeat content across insights

üü† FORMAT:
Respond ONLY in JSON format:
{
  "insights": [
    { "title": "...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." },
    ... (1-3 items total)
  ]
}

Note: 
- "title": Short, concise phrase (10-18 words) displayed on the node
- "description": Detailed explanation (1-3 sentences) shown when node is clicked
- "keyword" should be a concise 2‚Äì5 word phrase capturing the main meaning.
- "critic" (optional): Must be only ONE sentence under 18 words, and must be a short challenging question from a different perspective that provokes reflection (must end with "?"). Example critic patterns: questioning hidden causes, challenging assumptions, reconsidering boundaries. If no meaningful critic applies, omit this field.
- "advice" (optional): Must be only ONE sentence under 18 words, and must be a brief strategy-oriented suggestion that deepens or expands the idea. Example advice patterns: creative reframing strategies, gamification patterns, exploring cross-modal cues. Do not include solutions or implementation details. If no meaningful advice applies, omit this field.`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      const newAiCount = aiGenerationCount + 1;
      setAiGenerationCount(newAiCount);

      // Get parent position (will be calculated by getNodePosition)
      const parentPos = getNodePosition(parentNode);
      const siblingCount = parsed.insights.length;

      const newNodes = parsed.insights.map((insightObj, index) => {
        const nodeId = Date.now() + index * 10000 + Math.floor(Math.random() * 1000);

        // Create reflections if provided (critic, advice)
        const reflectionTypes = [
          { type: 'critic', data: insightObj.critic },
          { type: 'advice', data: insightObj.advice }
        ];

        reflectionTypes.forEach((refType, idx) => {
          if (refType.data && typeof refType.data === 'string' && refType.data.trim()) {
            setReflections(prev => [{
              id: nodeId + 10000 + idx,
              nodeId: nodeId,
              topic: insightObj.title || insightObj.text, // Keep node text for reference
              title: refType.data.trim(), // Use the reflection text as title
              content: refType.data.trim(), // Same content for display
              type: refType.type
            }, ...prev]);
          }
        });

        // Calculate initial position (will be adjusted by getNodePosition for collision avoidance)
        // Calculate initial position with collision detection during creation only
        const spacing = 110;
        const centerOffset = (siblingCount - 1) * spacing / 2;
        const baseX = parentPos.x + (index * spacing) - centerOffset;
        const baseY = parentPos.y + 120;

        // Apply collision detection only during initial creation
        const nodeSize = 90; // insight node size
        const allExistingNodes = nodes.filter(n => n.id !== nodeId);
        const adjustedPos = findNonCollidingPosition({ x: baseX, y: baseY }, nodeSize, allExistingNodes, nodeId);
        const initialX = adjustedPos.x;
        const initialY = adjustedPos.y;

        return {
          id: nodeId,
          title: insightObj.title || insightObj.text || '',
          description: insightObj.description || '',
          text: insightObj.text || insightObj.title || '', // For backward compatibility
          keyword: insightObj.keyword || extractKeyword(insightObj.title || insightObj.text || ''),
          type: 'insight',
          step: 3,
          category: 'Insight', // Always set category to "Insight" for insight nodes
          parentId: parentNode.id,
          x: initialX,
          y: initialY,
          level: 2,
          manuallyPositioned: false
        };
      });

      // Add nodes with sequential animation
      addNodesWithAnimation(newNodes, 300);
      setCurrentStep(4); // Move to step 4 after step 3 completion

      // Track Create Node event as a batch
      if (newNodes.length > 0) {
        const nodeIds = newNodes.map(n => n.id.toString());
        const combinedContent = newNodes.map(n => n.text).join(' ');
        const avgContentLength = combinedContent.length / newNodes.length;

        trackEvent('Create Node', 'AI', {
          node_id: nodeIds[0],
          node_ids_involved: nodeIds,
          new_content: combinedContent,
          node_count: newNodes.length,
          content_length: avgContentLength
        });
      }

      const newMetrics = calculateCreativityIndex();
      setCreativityHistory(prev => [...prev, newMetrics]);

      return newNodes;
    } catch (err) {
      console.error('Step 3 generation error:', err);
      alert('An error occurred while generating insights.');
      return [];
    }
  };


  // Step 4: Design Opportunities - Helper for multi-selection (returns nodes)
  const generateStep4OpportunitiesForMulti = async (parentNode) => {
    if (parentNode.type !== 'insight' || parentNode.step !== 3) return [];

    const existingChildren = nodes.filter(n => n.parentId === parentNode.id || (n.parentIds && n.parentIds.includes(parentNode.id)));
    if (existingChildren.length > 0) return [];

    return await generateStep4OpportunitiesInternal(parentNode);
  };

  // Step 4: Design Opportunities - Internal function
  const generateStep4OpportunitiesInternal = async (parentNode) => {
    try {
      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2000,
          messages: [
            {
              role: "user",
              content: `Given a user behavior insight, generate 1-3 Design Opportunities (generate 1, 2, or 3 based on what makes sense).

Insight: ${parentNode.text}

üî∂ STEP 4: DESIGN OPPORTUNITY GENERATION

üü¢ GOAL:
Generate 1-3 Design Opportunities per insight. A Design Opportunity is:
- A conceptual **reframing of a problem**
- A potential **space for innovation or exploration**
- NOT a solution, UI, or feature

üü° CONSTRAINTS:
- Generate 1, 2, or 3 opportunities (choose the number that makes most sense)
- DO NOT include technology, tools, or implementation (e.g., "AI," "Camera," "QR Code," etc.)
- DO NOT copy or paraphrase the insight
- DO NOT propose features
- Each opportunity must be 8‚Äì16 words
- Must be conceptually distinct and usable as a prompt for future ideation
- Focus on the problem space, not solution space

üü† FORMAT:
Respond ONLY in JSON format:
{
  "opportunities": [
    { "title": "Opportunity to...", "description": "...", "keyword": "...", "critic": "...", "advice": "..." },
    ... (1-3 items total)
  ]
}

Note:
- "title": Short, concise phrase (8-16 words) displayed on the node
- "description": Detailed explanation (1-3 sentences) shown when node is clicked

Note: 
- "keyword" should be a concise 2‚Äì5 word phrase capturing the main meaning.
- "critic" (optional): Must be only ONE sentence under 18 words, and must be a short challenging question from a different perspective that provokes reflection (must end with "?"). Example critic patterns: questioning hidden causes, challenging assumptions, reconsidering boundaries. If no meaningful critic applies, omit this field.
- "advice" (optional): Must be only ONE sentence under 18 words, and must be a brief strategy-oriented suggestion that deepens or expands the idea. Example advice patterns: creative reframing strategies, gamification patterns, exploring cross-modal cues. Do not include solutions or implementation details. If no meaningful advice applies, omit this field.`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      const newAiCount = aiGenerationCount + 1;
      setAiGenerationCount(newAiCount);

      // Get parent position (will be calculated by getNodePosition)
      const parentPos = getNodePosition(parentNode);
      const siblingCount = parsed.opportunities.length;

      const newNodes = parsed.opportunities.map((oppObj, index) => {
        const nodeId = Date.now() + index * 10000 + Math.floor(Math.random() * 1000);

        // Create reflections if provided (critic, advice)
        const reflectionTypes = [
          { type: 'critic', data: oppObj.critic },
          { type: 'advice', data: oppObj.advice }
        ];

        reflectionTypes.forEach((refType, idx) => {
          if (refType.data && typeof refType.data === 'string' && refType.data.trim()) {
            setReflections(prev => [{
              id: nodeId + 10000 + idx,
              nodeId: nodeId,
              topic: oppObj.title || oppObj.text, // Keep node text for reference
              title: refType.data.trim(), // Use the reflection text as title
              content: refType.data.trim(), // Same content for display
              type: refType.type
            }, ...prev]);
          }
        });

        // Calculate initial position (will be adjusted by getNodePosition for collision avoidance)
        // Calculate initial position with collision detection during creation only
        const spacing = 100;
        const centerOffset = (siblingCount - 1) * spacing / 2;
        const baseX = parentPos.x + (index * spacing) - centerOffset;
        const baseY = parentPos.y + 120;

        // Apply collision detection only during initial creation
        const nodeSize = 80; // opportunity node size
        const allExistingNodes = nodes.filter(n => n.id !== nodeId);
        const adjustedPos = findNonCollidingPosition({ x: baseX, y: baseY }, nodeSize, allExistingNodes, nodeId);
        const initialX = adjustedPos.x;
        const initialY = adjustedPos.y;

        return {
          id: nodeId,
          title: oppObj.title || oppObj.text || '',
          description: oppObj.description || '',
          text: oppObj.text || oppObj.title || '', // For backward compatibility
          keyword: oppObj.keyword || extractKeyword(oppObj.title || oppObj.text || ''),
          type: 'opportunity',
          step: 4,
          category: 'Design Opportunity', // Always set category to "Design Opportunity" for opportunity nodes
          parentId: parentNode.id,
          x: initialX,
          y: initialY,
          level: 3,
          manuallyPositioned: false
        };
      });

      // Add nodes with sequential animation
      addNodesWithAnimation(newNodes, 300);

      // Track Create Node event as a batch
      if (newNodes.length > 0) {
        const nodeIds = newNodes.map(n => n.id.toString());
        const combinedContent = newNodes.map(n => n.text).join(' ');
        const avgContentLength = combinedContent.length / newNodes.length;

        trackEvent('Create Node', 'AI', {
          node_id: nodeIds[0],
          node_ids_involved: nodeIds,
          new_content: combinedContent,
          node_count: newNodes.length,
          content_length: avgContentLength
        });
      }

      const newMetrics = calculateCreativityIndex();
      setCreativityHistory(prev => [...prev, newMetrics]);

      return newNodes;
    } catch (err) {
      console.error('Step 4 generation error:', err);
      alert('An error occurred while generating design opportunities.');
      return [];
    }
  };

  // Step 4: Design Opportunities - Public function (for single selection)
  const generateStep4Opportunities = async (parentNode) => {
    if (parentNode.type !== 'insight' || parentNode.step !== 3) return;

    const existingChildren = nodes.filter(n => n.parentId === parentNode.id);
    if (existingChildren.length > 0) return;

    setLoading(true);
    await generateStep4OpportunitiesInternal(parentNode);
    setLoading(false);
  };

  // Legacy function name for compatibility (Step 1 wrapper)
  const generateIdeas = async (prompt, parentId = null) => {
    if (parentId === null) {
      // Step 1: Initial problem framing
      await generateStep1ProblemFraming(prompt);
    }
  };

  const analyzeHierarchy = async () => {
    if (selectedForStructure.size === 0) {
      alert('Please select at least one node to analyze.');
      return;
    }

    setAnalyzingStructure(true);
    try {
      const selectedNodesData = nodes
        .filter(n => selectedForStructure.has(n.id))
        .map(node => ({
          id: node.id,
          text: node.text,
          parentId: node.parentId,
          level: node.level,
          hasReflection: reflections.some(r => r.nodeId === node.id)
        }));

      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 3000,
          messages: [
            {
              role: "user",
              content: `Analyze the following design opportunities using a comparative Impact‚ÄìFeasibility evaluation framework. 
Your goal is to produce a meaningful distribution of ideas across different quadrants, avoiding clustering all ideas into the same region unless strictly justified.

Ideas:
${JSON.stringify(selectedNodesData, null, 2)}

===========================
EVALUATION PRINCIPLES
===========================

You MUST score ideas **relative to each other**, not independently.

Use the FULL 1‚Äì10 scale:
- 1‚Äì3 = low
- 4‚Äì6 = medium
- 7‚Äì10 = high

Avoid clustering:
- Do NOT place all ideas in the same quadrant.
- Variability in scores must come from **comparisons**, **penalties**, and **distinct strengths/weaknesses**.
- Do NOT use uniformly high scores (6‚Äì9). 
- Spread must feel natural and analytically justified, not artificially forced.

===========================
IMPACT SCORING LOGIC
===========================

Impact = user value √ó severity √ó relevance.

High impact (7‚Äì10) only if:
- Addresses a high-frequency, high-stakes, or deeply disruptive pain point.
- Provides substantial improvement to user experience or behavioral outcome.

Medium impact (4‚Äì6) if:
- Addresses a moderate or situational need.
- Contributes partially to solving the root issue.

Low impact (1‚Äì3) if ANY penalties apply:
- Idea is vague, generic, or overly broad.
- Poorly connected to a real user pain point.
- User group is underspecified.
- Outcome is low value or marginal improvement.
- Problem applies only in edge cases.

===========================
FEASIBILITY SCORING LOGIC
===========================

Feasibility = technical simplicity + resource load + coordination overhead.

High feasibility (7‚Äì10) only if:
- Low technical complexity.
- Minimal integration effort.
- Low operational cost.
- Clear path to execution.

Medium feasibility (4‚Äì6) if:
- Some uncertainty exists.
- Requires moderate integration or behavior adoption.

Low feasibility (1‚Äì3) if ANY penalties apply:
- Requires multi-organization coordination or complex infrastructure.
- Relies on volatile or hard-to-measure user behavior.
- Depends on missing data, unstable signals, or high privacy risk.
- High effort demanded from users or administrators.

===========================
DISTRIBUTION GUIDELINES
===========================

Do NOT force ideas into all four quadrants.

Instead:
- Ensure a realistic spread across quadrants.
- Prevent all ideas from collapsing into the same quadrant.
- Allow 0‚Äì2 empty quadrants if logically justified (e.g., theme-specific constraints).
- The distribution must emerge from the scoring logic‚Äînot arbitrary balancing.

The goal is **analytical differentiation**, not symmetry.

===========================
OUTPUT REQUIREMENTS
===========================

For each idea provide:
1. impact: number 1‚Äì10  
2. feasibility: number 1‚Äì10  
3. category: 1‚Äì4 word conceptual cluster  
4. insight: 1‚Äì2 concise sentences explaining the reasoning (problem-space only)  
5. recommendedAction: 1 sentence using quadrant logic explicitly:
   - Quick Wins ‚Üí "prioritize"
   - Big Bets ‚Üí "explore constraints or phased strategy"
   - Fill-ins ‚Üí "address selectively when aligned"
   - Maybe Later ‚Üí "defer or discard"

ALSO provide:
- mainThemes: 3‚Äì5 conceptual problem-space themes  
- relationships: 3‚Äì6 concise statements describing dependencies, contrasts, or overlaps  

Keep all text short, analytical, and avoid features, solutions, or technologies.

===========================
JSON-ONLY OUTPUT FORMAT
===========================

{
  "analysis": [
    {
      "nodeId": number,
      "impact": number,
      "feasibility": number,
      "category": "string",
      "insight": "string",
      "recommendedAction": "string"
    }
  ],
  "mainThemes": ["string", ...],
  "relationships": ["string", ...]
}`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      // Store the index when Structure Mode starts
      parsed.structureModeStartIndex = creativityHistory.length;

      setHierarchyAnalysis(parsed);

      const newStructureReflections = [];
      parsed.analysis.forEach((analysis, index) => {
        if (analysis.reflection) {
          const node = selectedNodesData.find(n => n.id === analysis.nodeId);
          newStructureReflections.push({
            id: Date.now() + index,
            nodeId: analysis.nodeId,
            topic: node?.text || 'Unknown',
            content: analysis.reflection,
            timestamp: new Date().toLocaleTimeString()
          });
        }
      });
      setStructureReflections(newStructureReflections);

      // Pre-calculate initial positions for all nodes ONLY if this is a NEW structure analysis
      // Check if we already have positions for these nodes (preserving existing structure)
      const existingPositions = parsed.analysis.filter(analysis =>
        structureGridPositions[analysis.nodeId]
      );

      // Only calculate initial positions if this is a new structure (no existing positions)
      if (existingPositions.length === 0) {
        // Use setTimeout to ensure DOM is ready after mode change
        setTimeout(() => {
          const graphContainer = document.getElementById('structure-graph-container');
          if (graphContainer) {
            const graphWidth = 800;
            const graphHeight = 600;
            const margin = 100;
            const initialPositions = {};

            parsed.analysis.forEach(analysis => {
              const clampedFeasibility = Math.max(1, Math.min(10, analysis.feasibility || 5));
              const clampedImpact = Math.max(1, Math.min(10, analysis.impact || 5));

              // Calculate position within graph bounds (relative to graph container)
              const availableWidth = graphWidth - 2 * margin;
              const availableHeight = graphHeight - 2 * margin;

              const graphX = margin + ((clampedFeasibility - 1) / 9) * availableWidth;
              const graphY = (graphHeight - margin) - ((clampedImpact - 1) / 9) * availableHeight;

              // Clamp to graph bounds
              const clampedGraphX = Math.max(margin, Math.min(graphWidth - margin, graphX));
              const clampedGraphY = Math.max(margin, Math.min(graphHeight - margin, graphY));

              initialPositions[analysis.nodeId] = {
                x: clampedGraphX,
                y: clampedGraphY
              };
            });

            setStructureGridPositions(initialPositions);
          }
        }, 100);
      }
      // If positions already exist, they will be preserved and used in getStructuredPosition

      // Track Selection event for structure mode (CSV criteria)
      const selectedCount = selectedForStructure.size;
      if (selectedCount > 0) {
        trackEvent('Select Nodes for Structure', 'HUMAN', {
          node_ids: Array.from(selectedForStructure).map(id => id.toString()),
          selection_count: selectedCount
        });
      }

      // Store selected node IDs for structure mode display (before clearing selection)
      setStructureSelectedNodeIds(new Set(selectedForStructure));

      // Clear selection after storing for structure mode
      setSelectedForStructure(new Set());
      setMode('structure');
    } catch (err) {
      console.error('Analysis error:', err);
      alert('An error occurred while analyzing the hierarchy.');
    }
    setAnalyzingStructure(false);
  };

  const toggleNodeSelection = (nodeId) => {
    setSelectedForStructure(prev => {
      const newSet = new Set(prev);
      if (newSet.has(nodeId)) {
        newSet.delete(nodeId);
      } else {
        newSet.add(nodeId);
      }
      return newSet;
    });
  };

  const handleNodeClick = (node, e) => {
    if (editingNode === node.id) return;

    // Shift + Click: Toggle structure selection (toggle on/off)
    if (e && e.shiftKey) {
      toggleNodeSelection(node.id);
      // Also update selectedNode for visual feedback
      setSelectedNode(node.id);
      return;
    }

    // Normal click: clear multi-selection if active
    if (selectedForStructure.size > 0) {
      // Clear multi-selection completely (don't keep single selection for structure mode)
      setSelectedForStructure(new Set());
      setSelectedNode(node.id);
      return;
    }

    // Normal click: toggle single selection (no multi-selection active)
    // Also add to selectedForStructure so it counts as 1 selection for Structure Mode
    if (selectedNode === node.id) {
      // Deselecting
      setSelectedNode(null);
      setSelectedForStructure(new Set());
    } else {
      // Selecting
      setSelectedNode(node.id);
      setSelectedForStructure(new Set([node.id]));
    }
  };

  const handleEdit = (node) => {
    setEditingNode(node.id);
    setEditValue(node.text);
    setSelectedNode(null);
  };

  const handleEditSave = () => {
    const nodeToEdit = nodes.find(n => n.id === editingNode);
    if (!nodeToEdit) return;

    setNodes(prev => prev.map(n =>
      n.id === editingNode ? { ...n, text: editValue, edited: true } : n
    ));

    // Track Edit Node event
    trackEvent('Edit Node', 'HUMAN', {
      node_id: editingNode.toString(),
      raw_content: nodeToEdit.text,
      new_content: editValue
    });

    const newEditCount = editCount + 1;
    setEditCount(newEditCount);

    const newMetrics = calculateCreativityIndex();
    setCreativityHistory(prev => {
      const updated = [...prev];
      // If structure mode has started, add new entry instead of updating last one
      const structureModeStartIndex = hierarchyAnalysis?.structureModeStartIndex ?? null;
      if (structureModeStartIndex !== null && prev.length >= structureModeStartIndex) {
        // Structure mode is active, add new entry
        return [...prev, newMetrics];
      } else if (updated.length > 0) {
        // Exploration mode, update last entry
        updated[updated.length - 1] = newMetrics;
      }
      return updated;
    });

    setEditingNode(null);
    setEditValue('');
  };

  // Multi-selection Generate: AI decides what to generate based on selected nodes
  const generateMultiSelection = async (selectedNodesList) => {
    if (selectedNodesList.length === 0) return;

    setLoading(true);
    try {
      // Use current nodes state for generation
      const currentNodes = nodes;
      // Build context from selected nodes with their text for matching
      const nodesInfo = selectedNodesList.map((node, idx) => ({
        index: idx + 1,
        text: node.text,
        type: node.type,
        step: node.step,
        category: node.category || null
      }));

      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 3000,
          messages: [
            {
              role: "user",
              content: `You are analyzing selected nodes from a design thinking framework to determine what new nodes should be generated.

Design Topic: "${designTopic || 'Design topic'}"

Selected Nodes:
${nodesInfo.map(n => `${n.index}. [${n.type}, Step ${n.step}${n.category ? `, ${n.category}` : ''}] "${n.text}"`).join('\n')}

Available Framework Steps:
- Step 1: Main nodes (Context, User, Task, Goal) - type: "main"
- Step 2: Sub-nodes - type: "sub" 
- Step 3: User Behavior Insights - type: "insight"
- Step 4: Design Opportunities - type: "opportunity"

Your task:
1. Analyze the selected nodes and the design context
2. Determine what type(s) of nodes should be generated next - be creative and flexible
3. You can generate:
   - Main nodes (if missing categories or new perspective needed)
   - Sub-nodes (for main nodes - optional intermediate step)
   - Insights (for main nodes OR sub-nodes) - main nodes should directly generate insights
   - Opportunities (for insights)
   - OR any combination - don't limit yourself to "next step" only!

Important: Main nodes (Context, User, Task, Goal) should directly generate insights, not sub-nodes.

Constraints:
- Generate 1-3 nodes per selected node
- Follow the framework structure but be flexible
- Generate what makes most sense for advancing the design thinking process
- Each node should follow its step's constraints

Respond ONLY in JSON format:
{
  "decisions": [
    {
      "selectedNodeIndex": 1-${nodesInfo.length} (which selected node to generate from),
      "nodeType": "main" | "sub" | "insight" | "opportunity",
      "step": 1 | 2 | 3 | 4,
      "category": "Context" | "User" | "Task" | "Goal" | null,
      "reasoning": "Brief explanation why this generation makes sense"
    }
  ]
}`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      // Process each decision and generate nodes
      // Collect all generated nodes to link them to all selected nodes
      const allGeneratedNodes = [];

      for (const decision of parsed.decisions) {
        const targetNode = selectedNodesList[decision.selectedNodeIndex - 1];
        if (!targetNode) continue;

        let generatedNodes = [];

        // Generate based on decision - use appropriate function
        if (decision.nodeType === 'main') {
          // Generate new main node
          const newNode = await generateMainNodeFromMulti(decision.category || 'Context');
          if (newNode) generatedNodes = [newNode];
        } else if (decision.nodeType === 'sub') {
          // Check if targetNode can have sub-nodes (main node)
          if (targetNode.type === 'main') {
            generatedNodes = await generateStep2SubNodesForMulti(targetNode);
          }
        } else if (decision.nodeType === 'insight') {
          // Check if targetNode can have insights (main node or sub node)
          if (targetNode.type === 'main' || targetNode.type === 'sub') {
            generatedNodes = await generateStep3InsightsForMulti(targetNode);
          }
        } else if (decision.nodeType === 'opportunity') {
          // Check if targetNode can have opportunities (insight)
          if (targetNode.type === 'insight') {
            generatedNodes = await generateStep4OpportunitiesForMulti(targetNode);
          }
        }

        allGeneratedNodes.push(...generatedNodes);
      }

      // Link all generated nodes to all selected nodes (if multiple selected)
      if (allGeneratedNodes.length > 0 && selectedNodesList.length > 1) {
        const parentIds = selectedNodesList.map(sn => sn.id);
        setNodes(prev => prev.map(node => {
          if (allGeneratedNodes.some(gn => gn.id === node.id)) {
            // Add all selected node IDs as parents
            return { ...node, parentIds: parentIds, parentId: parentIds[0] }; // Keep parentId for backward compatibility
          }
          return node;
        }));
      }

      const newAiCount = aiGenerationCount + 1;
      setAiGenerationCount(newAiCount);

      const newMetrics = calculateCreativityIndex();
      setCreativityHistory(prev => [...prev, newMetrics]);
    } catch (err) {
      console.error('Multi-selection generation error:', err);
      alert('An error occurred while generating from selected nodes.');
    }
    setLoading(false);
  };

  // Helper: Generate main node from multi-selection (returns node)
  const generateMainNodeFromMulti = async (category) => {
    // Reuse Step 1 logic but for single node
    try {
      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2000,
          messages: [
            {
              role: "user",
              content: `Given a design topic, generate ONE problem-framing node for the ${category} category.

Design Topic: "${designTopic || 'Design topic'}"

üî∂ STEP 1: PROBLEM FRAMING

üü¢ GOAL:
Generate ONE main problem-framing node for ${category}:
${category === 'Context' ? '- Context: Where does the problem occur?' : ''}
${category === 'User' ? '- User: Who is involved and what characterizes them?' : ''}
${category === 'Task' ? '- Task: What actions, behaviors, or processes are relevant?' : ''}
${category === 'Goal' ? '- Goal: What outcome or value is the user pursuing?' : ''}

üü° CONSTRAINTS:
- Output only ONE node title
- No sub-details, no insights, no opinions
- Do NOT include any opportunities or solutions
- Should be a concise phrase (5-10 words)

üü† FORMAT (MUST FOLLOW EXACTLY):
Respond ONLY in JSON format:
{
  "title": "...",
  "description": "...",
  "keyword": "...",
  "critic": "...",
  "advice": "..."
}

Note:
- "title": Short, concise phrase (5-10 words) displayed on the node
- "description": Detailed explanation (1-3 sentences) shown when node is clicked

Note: 
- "keyword" should be a concise 2‚Äì5 word phrase capturing the main meaning.
- "critic" (optional): Must be only ONE sentence under 18 words, and must be a short challenging question from a different perspective that provokes reflection (must end with "?"). Example critic patterns: questioning hidden causes, challenging assumptions, reconsidering boundaries. If no meaningful critic applies, omit this field.
- "advice" (optional): Must be only ONE sentence under 18 words, and must be a brief strategy-oriented suggestion that deepens or expands the idea. Example advice patterns: creative reframing strategies, gamification patterns, exploring cross-modal cues. Do not include solutions or implementation details. If no meaningful advice applies, omit this field.`
            }
          ],
        })
      });

      const data = await response.json();

      // Check if response has error
      if (data.error) {
        console.error('API error:', data);
        alert(`API Error: ${data.error}${data.hint ? '\n' + data.hint : ''}`);
        setLoading(false);
        return;
      }

      // Check if response has content
      if (!data.content || !data.content[0] || !data.content[0].text) {
        console.error('Unexpected response format:', data);
        alert('Unexpected response format from API. Please check the console for details.');
        setLoading(false);
        return;
      }

      const text = data.content[0].text.trim();
      const cleanText = text.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleanText);

      const existingMainNodes = nodes.filter(n => n.type === 'main' && n.step === 1);
      const nodeId = Date.now() + Math.floor(Math.random() * 10000);

      // Create reflections if provided (critic, advice)
      const reflectionTypes = [
        { type: 'critic', data: parsed.critic },
        { type: 'advice', data: parsed.advice }
      ];

      reflectionTypes.forEach((refType, idx) => {
        if (refType.data && typeof refType.data === 'string' && refType.data.trim()) {
          setReflections(prev => [{
            id: nodeId + 10000 + idx,
            nodeId: nodeId,
            topic: parsed.title || parsed.text, // Keep node text for reference
            title: refType.data.trim(), // Use the reflection text as title
            content: refType.data.trim(), // Same content for display
            type: refType.type
          }, ...prev]);
        }
      });

      // Calculate initial position (will be adjusted by getNodePosition during rendering for collision avoidance)
      // For main nodes, position them relative to existing main nodes or center
      const topicNode = nodes.find(n => n.type === 'topic');
      const topicPos = topicNode ? getNodePosition(topicNode) : { x: 400, y: 200 };
      const spacing = 150;
      const centerOffset = (existingMainNodes.length * spacing) / 2;
      const initialX = topicPos.x + (existingMainNodes.length * spacing) - centerOffset;
      const initialY = topicPos.y + 120;

      const newNode = {
        id: nodeId,
        title: parsed.title || parsed.text || '',
        description: parsed.description || '',
        text: parsed.text || parsed.title || '', // For backward compatibility
        keyword: parsed.keyword || extractKeyword(parsed.title || parsed.text || ''),
        type: 'main',
        step: 1,
        category: category,
        parentId: topicNode?.id || null,
        x: initialX,
        y: initialY,
        level: 0,
        manuallyPositioned: false
      };

      // Add node with animation
      addNodesWithAnimation([newNode], 0);
      return newNode;
    } catch (err) {
      console.error('Main node generation error:', err);
      alert(`An error occurred while generating ${category} node.`);
      return null;
    }
  };

  const handleGenerate = (node) => {
    // Check if multiple nodes are selected
    const selectedNodes = Array.from(selectedForStructure);
    if (selectedNodes.length > 1) {
      // Multi-selection generate
      const selectedNodesList = nodes.filter(n => selectedNodes.includes(n.id));
      generateMultiSelection(selectedNodesList);
      setSelectedForStructure(new Set());
      setSelectedNode(null);
      return;
    }

    // Single node generate - Route to appropriate step based on node type
    if (node.type === 'main' && node.step === 1) {
      generateStep2SubNodes(node);
    } else if (node.type === 'sub' && node.step === 2) {
      generateStep3Insights(node);
    } else if (node.type === 'insight' && node.step === 3) {
      generateStep4Opportunities(node);
    } else {
      // Legacy fallback
      generateIdeas(node.text, node.id);
    }
    setSelectedNode(null);
  };

  // Handle manual node creation (user input)
  const handleAddNodeClick = (parentNode) => {
    setAddNodeModal(parentNode.id);
    setAddNodeText('');
    setHoveredNodeId(null);
  };

  const handleAddNodeSubmit = () => {
    if (!addNodeText.trim() || !addNodeModal) return;

    const parentNode = nodes.find(n => n.id === addNodeModal);
    if (!parentNode) return;

    // Determine child node type based on parent
    let childType, childStep, childLevel, childCategory;
    if (parentNode.type === 'topic') {
      childType = 'main';
      childStep = 1;
      childLevel = 0;
      childCategory = null; // Will be determined
    } else if (parentNode.type === 'main' && parentNode.step === 1) {
      childType = 'sub';
      childStep = 2;
      childLevel = 1;
      childCategory = parentNode.category;
    } else if (parentNode.type === 'sub' && parentNode.step === 2) {
      childType = 'insight';
      childStep = 3;
      childLevel = 2;
      childCategory = parentNode.category;
    } else if (parentNode.type === 'insight' && parentNode.step === 3) {
      childType = 'opportunity';
      childStep = 4;
      childLevel = 3;
      childCategory = parentNode.category;
    } else {
      // Default: create same level as parent
      childType = parentNode.type;
      childStep = parentNode.step;
      childLevel = parentNode.level;
      childCategory = parentNode.category;
    }

    // Calculate position for new node (similar to getNodePosition logic)
    const parentPos = getNodePosition(parentNode);
    const siblings = nodes.filter(n => {
      const nParentId = n.parentIds ? n.parentIds[0] : n.parentId;
      return nParentId === parentNode.id;
    });
    const spacing = childType === 'main' ? 150 : childType === 'sub' ? 130 : 110;
    // Position new node: index will be siblings.length, so position = (index - 1) * spacing
    // This centers the first child at parent, and spreads others evenly
    const index = siblings.length;
    const initialX = parentPos.x + (index - 1) * spacing;
    const initialY = parentPos.y + 120;

    // Create new node
    const newNodeId = Date.now();
    const newNode = {
      id: newNodeId,
      title: addNodeText.trim(), // User input becomes title
      description: '', // Description empty initially, can be edited later
      text: addNodeText.trim(), // For backward compatibility
      keyword: extractKeyword(addNodeText.trim()),
      type: childType,
      step: childStep,
      category: childCategory || null,
      parentId: parentNode.id,
      x: initialX,
      y: initialY,
      level: childLevel,
      manuallyPositioned: false
    };

    // Add node with animation
    addNodesWithAnimation([newNode], 0);

    // Track event
    trackEvent('Create Node', 'HUMAN', {
      node_id: newNodeId.toString(),
      new_content: addNodeText.trim(),
      node_count: 1,
      content_length: addNodeText.trim().length
    });

    // Update creativity metrics
    const newMetrics = calculateCreativityIndex();
    setCreativityHistory(prev => [...prev, newMetrics]);

    // Close modal
    setAddNodeModal(null);
    setAddNodeText('');
    setHoveredNodeId(null);
  };

  const handleAddNodeCancel = () => {
    setAddNodeModal(null);
    setAddNodeText('');
    setHoveredNodeId(null);
  };

  const handleHome = () => {
    // First, clear all localStorage data to prevent it from being restored
    localStorage.removeItem('ideaTreeData');

    // Then reset all data and return to landing page
    setNodes([]);
    setReflections([]);
    setCreativityHistory([]);
    setEditCount(0);
    setAiGenerationCount(0);
    setEventHistory([]); // Reset event history
    setSelectedForStructure(new Set());
    setStructureSelectedNodeIds(new Set());
    setHierarchyAnalysis(null);
    setStructureReflections([]); // Reset structure reflections
    setStructureGridPositions({}); // Reset structure grid positions
    setCurrentStep(1);
    setDesignTopic('');
    setTopicNodeId(null);
    setLandingInputValue('');
    setMode('exploration');
    setCurrentPage('main'); // Reset page to main
    setActiveTab('overview'); // Reset tab to overview
    setSelectedNode(null);
    setEditingNode(null);
    setEditValue('');
    setFocusedNode(null);
    setFocusedReflection(null);
    setExpandedReflectionId(null);
    setDraggingNode(null);
    setDragOffset({ x: 0, y: 0 });
    setIsPanning(false);
    setAnalyzingStructure(false);
    setInputValue('');
  };

  const handleExpandAll = async () => {
    // Find all leaf nodes (nodes with no children)
    const leafNodes = nodes.filter(node => {
      const hasChildren = nodes.some(n => {
        const nParentId = n.parentIds ? n.parentIds[0] : n.parentId;
        return nParentId === node.id;
      });
      return !hasChildren;
    });

    if (leafNodes.length === 0) {
      alert('No leaf nodes found to expand.');
      return;
    }

    setLoading(true);
    try {
      // Generate for each leaf node based on its type
      for (const node of leafNodes) {
        if (node.type === 'main' && node.step === 1) {
          await generateStep2SubNodes(node);
        } else if (node.type === 'sub' && node.step === 2) {
          await generateStep3Insights(node);
        } else if (node.type === 'insight' && node.step === 3) {
          await generateStep4Opportunities(node);
        }
        // Add small delay between generations to avoid overwhelming the API
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    } catch (err) {
      console.error('Expand all error:', err);
      alert('An error occurred while expanding nodes.');
    }
    setLoading(false);
  };

  const handleDelete = (nodeId) => {
    const nodeToDelete = nodes.find(n => n.id === nodeId);
    const deleteNodeAndChildren = (id) => {
      const children = nodes.filter(n => n.parentId === id);
      children.forEach(child => deleteNodeAndChildren(child.id));
      setNodes(prev => prev.filter(n => n.id !== id));
      setReflections(prev => prev.filter(r => r.nodeId !== id));
    };

    // Count total nodes to be deleted (including children)
    const countNodesToDelete = (id) => {
      const children = nodes.filter(n => n.parentId === id);
      return 1 + children.reduce((sum, child) => sum + countNodesToDelete(child.id), 0);
    };
    const deleteCount = countNodesToDelete(nodeId);

    deleteNodeAndChildren(nodeId);

    // Track Delete Node event
    if (nodeToDelete) {
      trackEvent('Delete Node', 'HUMAN', {
        node_id: nodeId.toString(),
        raw_content: nodeToDelete.text,
        delete_count: deleteCount
      });
    }

    setSelectedNode(null);
    setSelectedForStructure(prev => {
      const newSet = new Set(prev);
      newSet.delete(nodeId);
      return newSet;
    });
  };

  const handleDeleteReflection = (reflectionId) => {
    setReflections(prev => prev.filter(r => r.id !== reflectionId));
  };

  const handleReflectionClick = (reflectionId, nodeId) => {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Toggle expand state
    setExpandedReflectionId(prev => prev === reflectionId ? null : reflectionId);

    // Focus and select the node
    setFocusedNode(nodeId);
    setSelectedNode(nodeId);

    // Scroll to the node
    const nodeElement = nodeRefs.current[nodeId];
    if (nodeElement) {
      nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Clear focus after 2 seconds, but keep selection
    setTimeout(() => setFocusedNode(null), 2000);
  };

  const handleReflectionAlertClick = (nodeId) => {
    const reflection = structureReflections.find(r => r.nodeId === nodeId);
    if (!reflection) return;

    setFocusedReflection(reflection.id);

    const reflectionElement = reflectionRefs.current[reflection.id];
    if (reflectionElement) {
      reflectionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    setTimeout(() => setFocusedReflection(null), 2000);
  };

  const handleMouseDown = (e, node) => {
    // Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú ÎìúÎûòÍ∑∏ Î∞©ÏßÄ
    if (editingNode === node.id ||
      e.target.closest('button') ||
      e.target.closest('.node-controls') ||
      e.target.tagName === 'BUTTON') {
      return;
    }

    // Store mouse down position to detect if it's a click or drag
    setMouseDownPos({ x: e.clientX, y: e.clientY });

    if (isSpacePressed) {
      // Start panning - find the canvas container
      const container = e.target.closest('.flex-1.overflow-auto.relative') ||
        document.querySelector('.flex-1.overflow-auto.relative');
      if (container) {
        setIsPanning(true);
        setPanStart({
          x: e.clientX + container.scrollLeft,
          y: e.clientY + container.scrollTop
        });
      }
    } else {
      // Start dragging node
      // Find the canvas container (the one with overflow-auto)
      const container = e.target.closest('.flex-1.overflow-auto.relative') ||
        document.querySelector('.flex-1.overflow-auto.relative');

      if (!container) return;

      const containerRect = container.getBoundingClientRect();
      const nodePos = getNodePosition(node);

      // Calculate offset from node center to mouse position
      const mouseX = e.clientX - containerRect.left + container.scrollLeft;
      const mouseY = e.clientY - containerRect.top + container.scrollTop;

      setDraggingNode(node.id);
      setDragOffset({
        x: mouseX - nodePos.x,
        y: mouseY - nodePos.y
      });
    }
    e.preventDefault();
    e.stopPropagation();
  };

  const handleCanvasMouseDown = (e) => {
    if (isSpacePressed && !e.target.closest('.absolute')) {
      setIsPanning(true);
      const container = e.currentTarget;
      setPanStart({
        x: e.clientX + container.scrollLeft,
        y: e.clientY + container.scrollTop
      });
      e.preventDefault();
    }
  };

  const handleMouseMove = (e) => {
    if (isPanning) {
      // Pan the canvas
      const container = e.currentTarget;
      container.scrollLeft = panStart.x - e.clientX;
      container.scrollTop = panStart.y - e.clientY;
      return;
    }

    if (!draggingNode) return;

    const container = e.currentTarget;
    const containerRect = container.getBoundingClientRect();
    const scrollLeft = container.scrollLeft;
    const scrollTop = container.scrollTop;

    // Calculate new position based on mouse position and offset
    const mouseX = e.clientX - containerRect.left + scrollLeft;
    const mouseY = e.clientY - containerRect.top + scrollTop;

    if (mode === 'structure') {
      // Convert screen position to graph position (within graph bounds)
      const graphContainer = document.getElementById('structure-graph-container');
      if (!graphContainer) return;

      const graphRect = graphContainer.getBoundingClientRect();
      const graphWidth = 800;
      const graphHeight = 600;
      const margin = 100;
      const nodeRadius = 8;

      // Calculate new node center position in screen coordinates
      // offset was calculated as: e.clientX - nodeCenterX, so nodeCenterX = e.clientX - offset
      const nodeCenterScreenX = e.clientX - dragOffset.x;
      const nodeCenterScreenY = e.clientY - dragOffset.y;

      // Convert screen coordinates to graph container relative coordinates
      const graphRelativeX = nodeCenterScreenX - graphRect.left;
      const graphRelativeY = nodeCenterScreenY - graphRect.top;

      // Clamp to graph bounds
      const clampedX = Math.max(margin, Math.min(graphWidth - margin, graphRelativeX));
      const clampedY = Math.max(margin, Math.min(graphHeight - margin, graphRelativeY));

      // Convert position to impact and feasibility scores (1-10)
      const availableWidth = graphWidth - 2 * margin;
      const availableHeight = graphHeight - 2 * margin;

      // Feasibility: x position ‚Üí 1 (left) to 10 (right)
      const feasibility = 1 + ((clampedX - margin) / availableWidth) * 9;

      // Impact: y position ‚Üí 10 (top) to 1 (bottom)
      const impact = 10 - ((clampedY - margin) / availableHeight) * 9;

      // Round to 1 decimal place and clamp to 1-10
      const roundedFeasibility = Math.max(1, Math.min(10, Math.round(feasibility * 10) / 10));
      const roundedImpact = Math.max(1, Math.min(10, Math.round(impact * 10) / 10));

      // Update hierarchyAnalysis with new impact and feasibility values
      if (hierarchyAnalysis) {
        setHierarchyAnalysis(prev => {
          if (!prev) return prev;
          return {
            ...prev,
            analysis: prev.analysis.map(a =>
              a.nodeId === draggingNode
                ? { ...a, impact: roundedImpact, feasibility: roundedFeasibility }
                : a
            )
          };
        });
      }

      // Store the position (relative to graph container)
      setStructureGridPositions(prev => ({
        ...prev,
        [draggingNode]: { x: clampedX, y: clampedY }
      }));

      setNodes(prev => prev.map(n =>
        n.id === draggingNode
          ? { ...n, x: clampedX, y: clampedY, structurePositioned: true, structureAdjusted: true }
          : n
      ));
      return; // Early return for structure mode
    }

    // Exploration mode: use container-relative coordinates
    const newX = mouseX - dragOffset.x;
    const newY = mouseY - dragOffset.y;

    setNodes(prev => prev.map(n =>
      n.id === draggingNode
        ? {
          ...n,
          x: Math.max(0, newX),
          y: Math.max(0, newY),
          manuallyPositioned: true
        }
        : n
    ));
  };

  // Helper function to determine quadrant from impact/feasibility
  const getQuadrant = (impact: number, feasibility: number) => {
    const isHighImpact = impact > 5;
    const isHighFeasibility = feasibility > 5;
    if (isHighImpact && isHighFeasibility) return 'Quick Wins';
    if (isHighImpact && !isHighFeasibility) return 'Big Bets';
    if (!isHighImpact && isHighFeasibility) return 'Fill-ins';
    return 'Maybe Later';
  };

  const handleMouseUp = (e) => {
    // Check if it was a click (not a drag) in structure mode
    if (draggingNode && mode === 'structure') {
      const movedDistance = Math.sqrt(
        Math.pow((e?.clientX || mouseDownPos.x) - mouseDownPos.x, 2) +
        Math.pow((e?.clientY || mouseDownPos.y) - mouseDownPos.y, 2)
      );
      // If moved less than 5px, treat it as a click and select the node
      if (movedDistance < 5) {
        setSelectedStructureNode(draggingNode);
        setNodeInitialPosition(null);
      } else {
        // Node was dragged - track the event and update creativityHistory
        const draggedNode = nodes.find(n => n.id === draggingNode);
        if (draggedNode && hierarchyAnalysis) {
          const analysis = hierarchyAnalysis.analysis.find(a => a.nodeId === draggingNode);
          if (analysis && nodeInitialPosition) {
            // Determine if node crossed quadrant boundary
            const initialQuadrant = getQuadrant(nodeInitialPosition.impact, nodeInitialPosition.feasibility);
            const finalQuadrant = getQuadrant(analysis.impact, analysis.feasibility);
            const crossedBoundary = initialQuadrant !== finalQuadrant;

            // Calculate move distance for within-boundary scoring
            const moveDistance = Math.sqrt(
              Math.pow(analysis.impact - nodeInitialPosition.impact, 2) +
              Math.pow(analysis.feasibility - nodeInitialPosition.feasibility, 2)
            );

            // Track event according to CSV criteria
            const eventType = crossedBoundary
              ? 'Move Node (cross-boundary)'
              : 'Move Node (within-boundary)';

            trackEvent(eventType, 'HUMAN', {
              node_id: draggingNode.toString(),
              impact: analysis.impact,
              feasibility: analysis.feasibility,
              initial_impact: nodeInitialPosition.impact,
              initial_feasibility: nodeInitialPosition.feasibility,
              move_distance: moveDistance,
              node_text: draggedNode.text || draggedNode.title || ''
            });

            // Update creativityHistory for structure mode
            const newMetrics = calculateCreativityIndex();
            setCreativityHistory(prev => {
              const structureModeStartIndex = hierarchyAnalysis?.structureModeStartIndex ?? null;
              if (structureModeStartIndex !== null && prev.length >= structureModeStartIndex) {
                // Structure mode is active, add new entry
                return [...prev, newMetrics];
              }
              return prev;
            });
          }
        }
        setNodeInitialPosition(null);
      }
    }

    setDraggingNode(null);
    setIsPanning(false);
    setMouseDownPos({ x: 0, y: 0 });
  };

  // Helper function to check if two nodes overlap
  const checkNodeCollision = (pos1, size1, pos2, size2, minDistance = 20) => {
    const distance = Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
    const minRequiredDistance = (size1 / 2) + (size2 / 2) + minDistance;
    return distance < minRequiredDistance;
  };

  // Helper function to find a non-colliding position using spiral search
  const findNonCollidingPosition = (initialPos, nodeSize, existingNodes, excludedNodeId = null) => {
    let currentPos = { ...initialPos };
    let spiralRadius = 0;
    let angle = 0;
    const maxAttempts = 100;
    let attempts = 0;
    const minDistance = 20;

    // Get node size function for other nodes
    const getOtherNodeSize = (otherNode) => {
      if (otherNode.type === 'topic') return 140;
      if (otherNode.type === 'main') return 120;
      if (otherNode.type === 'sub') return 100;
      if (otherNode.type === 'insight') return 90;
      return 80; // opportunity or default
    };

    // Helper to get node position directly from stored values (avoid recursion)
    const getStoredNodePosition = (otherNode) => {
      if (!otherNode) return { x: 400, y: 300 };
      // Use stored position if available, otherwise calculate from parent
      if (otherNode.manuallyPositioned && otherNode.x !== undefined && otherNode.y !== undefined) {
        return { x: otherNode.x, y: otherNode.y };
      }
      if (otherNode.x !== undefined && otherNode.y !== undefined) {
        return { x: otherNode.x, y: otherNode.y };
      }
      // Fallback: calculate from parent if parent exists
      const parentId = otherNode.parentIds ? otherNode.parentIds[0] : otherNode.parentId;
      if (parentId) {
        const parent = nodes.find(n => n.id === parentId);
        if (parent) {
          const parentPos = getStoredNodePosition(parent);
          const spacing = otherNode.type === 'main' ? 150 : otherNode.type === 'sub' ? 130 : 110;
          const siblings = nodes.filter(n => {
            const nParentId = n.parentIds ? n.parentIds[0] : n.parentId;
            return nParentId === parentId;
          });
          const index = siblings.findIndex(n => n.id === otherNode.id);
          return {
            x: parentPos.x + (index - 1) * spacing,
            y: parentPos.y + 120
          };
        }
      }
      return { x: otherNode.x || 400, y: otherNode.y || 300 };
    };

    while (attempts < maxAttempts) {
      let hasCollision = false;

      // Check collision with all existing nodes
      for (const otherNode of existingNodes) {
        if (excludedNodeId && otherNode.id === excludedNodeId) continue;

        // Use stored position directly to avoid recursion
        const otherNodePos = getStoredNodePosition(otherNode);
        const otherNodeSize = getOtherNodeSize(otherNode);

        if (checkNodeCollision(currentPos, nodeSize, otherNodePos, otherNodeSize, minDistance)) {
          hasCollision = true;
          break;
        }
      }

      if (!hasCollision) {
        return currentPos;
      }

      // Spiral search: increase radius and angle
      attempts++;
      if (attempts % 8 === 0) {
        spiralRadius += 30;
        angle = 0;
      } else {
        angle += Math.PI / 4; // 45 degrees
      }

      currentPos = {
        x: initialPos.x + spiralRadius * Math.cos(angle),
        y: initialPos.y + spiralRadius * Math.sin(angle)
      };
    }

    // If no position found, return a position far away
    return {
      x: initialPos.x + 500,
      y: initialPos.y + 500
    };
  };

  const getNodePosition = (node) => {
    // Safety check: if node is undefined or null, return default position
    if (!node) {
      return { x: 400, y: 300 };
    }

    // If node has been manually positioned (dragged), use that position
    if (node.manuallyPositioned) {
      return { x: node.x, y: node.y };
    }

    // Use first parentId if multiple parents exist
    const parentId = node.parentIds ? node.parentIds[0] : node.parentId;
    if (!parentId) return { x: node.x || 400, y: node.y || 300 };

    const parent = nodes.find(n => n.id === parentId);
    if (!parent) return { x: node.x || 400, y: node.y || 300 };

    const siblings = nodes.filter(n => {
      const nParentId = n.parentIds ? n.parentIds[0] : n.parentId;
      return nParentId === parentId;
    });
    const index = siblings.findIndex(n => n.id === node.id);
    const parentPos = getNodePosition(parent);

    // Adjust spacing for circular nodes
    const spacing = node.type === 'main' ? 150 : node.type === 'sub' ? 130 : 110;
    const basePosition = {
      x: parentPos.x + (index - 1) * spacing,
      y: parentPos.y + 120
    };

    // If node already has a position set, use it (no collision detection after initial creation)
    // Collision detection only happens during initial node creation, not during rendering or drag
    if (node.x !== undefined && node.y !== undefined) {
      return { x: node.x, y: node.y };
    }

    // This should not happen in normal flow, but return base position as fallback
    return basePosition;
  };

  const renderConnections = () => {
    const connections = [];
    const hasMultiSelection = selectedForStructure.size > 1;
    const selectedNodeIds = new Set(selectedForStructure);

    nodes.forEach(node => {
      // Support both single parentId and multiple parentIds
      const parentIds = node.parentIds || (node.parentId ? [node.parentId] : []);

      parentIds.forEach(parentId => {
        const parent = nodes.find(n => n.id === parentId);
        if (!parent) return;

        const parentPos = getNodePosition(parent);
        const nodePos = getNodePosition(node);

        // Calculate center of circular nodes
        const nodeSize = getNodeSizeForConnection(node);
        const parentSize = getNodeSizeForConnection(parent);

        // Check if this connection is between selected nodes
        const isSelectedConnection = hasMultiSelection &&
          (selectedNodeIds.has(parentId) && selectedNodeIds.has(node.id));

        // Check if this is a new connection (node is animating)
        const isNewConnection = node.isAnimating || animatingNodes.has(node.id);

        connections.push(
          <line
            key={`line-${parentId}-${node.id}`}
            x1={parentPos.x + parentSize / 2}
            y1={parentPos.y + parentSize / 2}
            x2={nodePos.x + nodeSize / 2}
            y2={nodePos.y + nodeSize / 2}
            stroke={isSelectedConnection ? "url(#multiSelectGradient)" : "#cbd5e1"}
            strokeWidth={isSelectedConnection ? "3" : "2"}
            className={isNewConnection ? "line-draw" : ""}
            style={{
              transition: isNewConnection ? 'none' : 'all 0.4s ease-out',
              filter: isSelectedConnection ? 'drop-shadow(0 0 3px rgba(168, 85, 247, 0.5))' : 'none'
            }}
          />
        );
      });
    });

    return connections;
  };

  const getNodeSizeForConnection = (node) => {
    // Return diameter for circular nodes
    if (node.type === 'topic') return 140;
    if (node.type === 'main') return 120;
    if (node.type === 'sub') return 100;
    if (node.type === 'insight') return 80;
    if (node.type === 'opportunity') return 80;
    return 100;
  };

  const currentMetrics = creativityHistory.length > 0
    ? creativityHistory[creativityHistory.length - 1]
    : { creativity: 0, dependency: 0 };
  const currentCreativity = currentMetrics.creativity || (typeof currentMetrics === 'number' ? currentMetrics : 0);
  const currentDependency = currentMetrics.dependency || 0;

  const getPriorityColor = (impact, feasibility) => {
    const isHighImpact = impact > 5;
    const isHighFeasibility = feasibility > 5;

    if (isHighImpact && isHighFeasibility) return 'border-green-500 bg-green-50';
    if (isHighImpact && !isHighFeasibility) return 'border-yellow-500 bg-yellow-50';
    if (!isHighImpact && isHighFeasibility) return 'border-blue-500 bg-blue-50';
    return 'border-gray-300 bg-white';
  };

  const getCategoryColor = (category) => {
    const colors = [
      'bg-purple-100 text-purple-800',
      'bg-blue-100 text-blue-800',
      'bg-green-100 text-green-800',
      'bg-pink-100 text-pink-800',
      'bg-orange-100 text-orange-800'
    ];
    const hash = category.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    return colors[hash % colors.length];
  };

  // Creativity Report Page - MUST check before Structure mode to allow navigation from Structure mode
  // This check ensures report page renders even when in Structure mode
  // The actual report page code is at line 3555 - we need to check here first
  // Since the report page code is below, we need to move it here OR add an early return

  // IMPORTANT: Report page MUST be checked before Structure mode
  // The report page code is at line 3563 - we'll duplicate the check here
  // Since JavaScript executes top-to-bottom, we need this check to run before Structure mode
  // This is a workaround - the proper solution would be to move the entire report page block here

  // Report page check - MUST be before Structure mode check
  // This allows navigation from Structure mode to report page
  // The actual report page code is at line 3566 - we need to move it here
  // For now, we'll add an early return that references the code below
  // TODO: Move the entire report page block (lines 3566-5872) to this location (before line 2870)

  // Creativity Report Page - MUST be checked before Structure mode
  // This allows navigation from Structure mode to report page
  // The actual report page code is at line 3574 - it needs to be moved here
  // For now, we'll keep the code below but add a check here that will be ignored
  // TODO: Move the entire report page block (lines 3574-5878) to this location (before line 2875)

  if (mode === 'structure') {
    // Use stored node IDs from structure analysis, not current selection
    const selectedNodes = nodes.filter(n => structureSelectedNodeIds.has(n.id));

    const getStructuredPosition = (node) => {
      if (!hierarchyAnalysis) return { x: 0, y: 0 };

      // Helper function to calculate offset from graph container to parent container
      const calculateOffset = () => {
        const graphContainer = document.getElementById('structure-graph-container');
        if (!graphContainer) return { x: 0, y: 0 };

        // Get the parent container (the .overflow-auto div)
        const parentContainer = graphContainer.closest('.overflow-auto');
        if (parentContainer) {
          const parentRect = parentContainer.getBoundingClientRect();
          const graphRect = graphContainer.getBoundingClientRect();
          // Calculate offset considering scroll position
          const scrollLeft = parentContainer.scrollLeft || 0;
          const scrollTop = parentContainer.scrollTop || 0;
          return {
            x: (graphRect.left - parentRect.left) + scrollLeft,
            y: (graphRect.top - parentRect.top) + scrollTop
          };
        }
        // Fallback: try parentElement
        if (graphContainer.parentElement) {
          const parentRect = graphContainer.parentElement.getBoundingClientRect();
          const graphRect = graphContainer.getBoundingClientRect();
          return {
            x: graphRect.left - parentRect.left,
            y: graphRect.top - parentRect.top
          };
        }
        return { x: 0, y: 0 };
      };

      // Priority 1: Use grid position if it exists (preserves user-adjusted or initial positions)
      if (structureGridPositions[node.id]) {
        // structureGridPositions stores graph-relative coordinates
        // Convert to parent container coordinates by adding offset
        const offset = calculateOffset();
        return {
          x: structureGridPositions[node.id].x + offset.x,
          y: structureGridPositions[node.id].y + offset.y
        };
      }

      // Priority 2: Use stored position if node has been positioned before
      if (node.structurePositioned && node.x !== undefined && node.y !== undefined) {
        const offset = calculateOffset();
        return {
          x: node.x + offset.x,
          y: node.y + offset.y
        };
      }

      const analysis = hierarchyAnalysis.analysis.find(a => a.nodeId === node.id);
      if (!analysis) return { x: 0, y: 0 };

      // Position based on Impact (Y-axis) and Feasibility (X-axis)
      const graphWidth = 800;
      const graphHeight = 600;
      const nodeRadius = 8;
      const margin = 100; // Match the margin used in grid rendering

      // Clamp values to 1-10 range
      const clampedFeasibility = Math.max(1, Math.min(10, analysis.feasibility || 5));
      const clampedImpact = Math.max(1, Math.min(10, analysis.impact || 5));

      // Calculate position within graph bounds (relative to graph container)
      // X-axis: feasibility maps from left (1) to right (10)
      const availableWidth = graphWidth - 2 * margin;
      const graphX = margin + ((clampedFeasibility - 1) / 9) * availableWidth;

      // Y-axis: impact maps from bottom (1) to top (10)
      const availableHeight = graphHeight - 2 * margin;
      const graphY = (graphHeight - margin) - ((clampedImpact - 1) / 9) * availableHeight;

      // Clamp to graph bounds (graph-relative coordinates)
      const clampedGraphX = Math.max(margin, Math.min(graphWidth - margin, graphX));
      const clampedGraphY = Math.max(margin, Math.min(graphHeight - margin, graphY));

      // Convert graph-relative coordinates to parent container coordinates
      // Use the same offset calculation helper
      const offset = calculateOffset();
      return {
        x: clampedGraphX + offset.x,
        y: clampedGraphY + offset.y
      };
    };

    const renderStructureConnections = () => {
      if (!hierarchyAnalysis) return null;

      const connections = [];
      const priorityOrder = ['high', 'medium', 'low'];

      // Group nodes by priority
      const nodesByPriority = {};
      selectedNodes.forEach(node => {
        const analysis = hierarchyAnalysis.analysis.find(a => a.nodeId === node.id);
        if (analysis) {
          if (!nodesByPriority[analysis.priority]) {
            nodesByPriority[analysis.priority] = [];
          }
          nodesByPriority[analysis.priority].push(node);
        }
      });

      // Connect nodes from higher to lower priority hierarchy
      for (let i = 0; i < priorityOrder.length - 1; i++) {
        const currentPriority = priorityOrder[i];
        const nextPriority = priorityOrder[i + 1];

        const currentNodes = nodesByPriority[currentPriority] || [];
        const nextNodes = nodesByPriority[nextPriority] || [];

        currentNodes.forEach(parentNode => {
          nextNodes.forEach(childNode => {
            const parentPos = getStructuredPosition(parentNode);
            const childPos = getStructuredPosition(childNode);
            const parentAnalysis = hierarchyAnalysis.analysis.find(a => a.nodeId === parentNode.id);
            const size = getNodeSize(parentAnalysis?.impact || 5, parentAnalysis?.feasibility || 5);

            connections.push(
              <line
                key={`struct-${parentNode.id}-${childNode.id}`}
                x1={parentPos.x + size / 2}
                y1={parentPos.y + 70}
                x2={childPos.x + size / 2}
                y2={childPos.y}
                stroke="#9333ea"
                strokeWidth="2"
                opacity="0.4"
              />
            );
          });
        });
      }

      return connections;
    };

    const getNodeSize = (impact, feasibility) => {
      // All circles are the same small size
      return 16; // diameter in pixels
    };

    const getQuadrantLabel = (impact, feasibility) => {
      const isHighImpact = impact > 5;
      const isHighFeasibility = feasibility > 5;

      if (isHighImpact && isHighFeasibility) return 'Quick Wins';
      if (isHighImpact && !isHighFeasibility) return 'Big Bets';
      if (!isHighImpact && isHighFeasibility) return 'Fill-ins';
      return 'Maybe Later';
    };

    const getQuadrantColor = (impact, feasibility) => {
      const isHighImpact = impact > 5;
      const isHighFeasibility = feasibility > 5;

      if (isHighImpact && isHighFeasibility) return '#10b981';
      if (isHighImpact && !isHighFeasibility) return '#f59e0b';
      if (!isHighImpact && isHighFeasibility) return '#3b82f6';
      return '#9ca3af';
    };

    const getCategoryColor = (category) => {
      const colors = [
        'bg-purple-100 text-purple-800',
        'bg-blue-100 text-blue-800',
        'bg-green-100 text-green-800',
        'bg-pink-100 text-pink-800',
        'bg-orange-100 text-orange-800'
      ];
      const hash = category.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return colors[hash % colors.length];
    };

    return (
      <div className="w-full h-screen bg-gradient-to-br from-purple-50 to-pink-50 flex flex-col">
        <div className="bg-white shadow-sm p-6">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-3xl font-bold text-gray-800">üèóÔ∏è Structure Mode</h1>
            <button
              onClick={() => setMode('exploration')}
              className="flex items-center gap-2 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700"
            >
              <ArrowLeft size={20} />
              Back to Exploration
            </button>
          </div>
          <div className="flex items-center gap-4">
            <p className="text-gray-600">Impact-Feasibility Matrix</p>
            {hierarchyAnalysis && (
              <div className="flex gap-2">
                {hierarchyAnalysis.mainThemes.slice(0, 3).map((theme, idx) => (
                  <span key={idx} className="px-3 py-1 bg-purple-100 text-purple-800 rounded-full text-xs font-semibold">
                    {theme}
                  </span>
                ))}
              </div>
            )}
          </div>
        </div>

        <div className="flex-1 flex overflow-hidden">
          <div
            className="flex-1 overflow-auto relative"
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            {analyzingStructure || !hierarchyAnalysis ? (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-[9999] flex items-center justify-center">
                <div className="bg-white rounded-xl shadow-2xl px-8 py-6 flex flex-col items-center gap-4 min-w-[200px]">
                  <div className="w-12 h-12 border-4 border-purple-200 border-t-purple-600 rounded-full animate-spin"></div>
                  <p className="text-gray-700 font-semibold text-lg">Analyzing structure...</p>
                  <p className="text-gray-500 text-sm">Please wait</p>
                </div>
              </div>
            ) : (
              <>
                {/* 2x2 Matrix Background */}
                <div className="absolute inset-0 flex items-center justify-center">
                  <div id="structure-graph-container" className="relative" style={{ width: '800px', height: '600px' }}>
                    {/* Quadrants - Background layer */}
                    <div className="absolute top-0 left-0 w-1/2 h-1/2 bg-yellow-50 border-r-2 border-b-2 border-gray-300" style={{ zIndex: 0 }}>
                      <div className="absolute top-2 left-2 text-xs font-semibold text-yellow-700">Big Bets</div>
                      <div className="absolute bottom-2 right-2 text-xs text-gray-400">High Impact, Low Feasibility</div>
                    </div>
                    <div className="absolute top-0 right-0 w-1/2 h-1/2 bg-green-50 border-l-2 border-b-2 border-gray-300" style={{ zIndex: 0 }}>
                      <div className="absolute top-2 right-2 text-xs font-semibold text-green-700">Quick Wins</div>
                      <div className="absolute bottom-2 left-2 text-xs text-gray-400">High Impact, High Feasibility</div>
                    </div>
                    <div className="absolute bottom-0 left-0 w-1/2 h-1/2 bg-gray-50 border-r-2 border-t-2 border-gray-300" style={{ zIndex: 0 }}>
                      <div className="absolute bottom-2 left-2 text-xs font-semibold text-gray-600">Maybe Later</div>
                      <div className="absolute top-2 right-2 text-xs text-gray-400">Low Impact, Low Feasibility</div>
                    </div>
                    <div className="absolute bottom-0 right-0 w-1/2 h-1/2 bg-blue-50 border-l-2 border-t-2 border-gray-300" style={{ zIndex: 0 }}>
                      <div className="absolute bottom-2 right-2 text-xs font-semibold text-blue-700">Fill-ins</div>
                      <div className="absolute top-2 left-2 text-xs text-gray-400">Low Impact, High Feasibility</div>
                    </div>

                    {/* Grid Lines and Score Labels - Overlay on top of quadrants */}
                    <svg className="absolute inset-0 pointer-events-none" style={{ zIndex: 1, width: '800px', height: '600px' }}>
                      {/* Vertical grid lines (Feasibility: 1-10) */}
                      {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(score => {
                        const graphWidth = 800;
                        const graphHeight = 600;
                        const margin = 100;
                        const availableWidth = graphWidth - 2 * margin;
                        const x = margin + ((score - 1) / 9) * availableWidth;
                        return (
                          <g key={`v-${score}`}>
                            <line
                              x1={x}
                              y1={0}
                              x2={x}
                              y2={graphHeight}
                              stroke="#e2e8f0"
                              strokeWidth={1}
                              strokeDasharray="4,4"
                            />
                            {/* Show score labels for odd numbers (1, 3, 5, 7, 9) and also 10 */}
                            {(score % 2 === 1 || score === 10) && (
                              <text
                                x={x}
                                y={graphHeight + 25}
                                textAnchor="middle"
                                className="text-xs fill-gray-600 font-medium"
                              >
                                {score}
                              </text>
                            )}
                          </g>
                        );
                      })}
                      {/* Horizontal grid lines (Impact: 1-10) */}
                      {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(score => {
                        const graphWidth = 800;
                        const graphHeight = 600;
                        const margin = 100;
                        const availableHeight = graphHeight - 2 * margin;
                        const y = (graphHeight - margin) - ((score - 1) / 9) * availableHeight;
                        return (
                          <g key={`h-${score}`}>
                            <line
                              x1={0}
                              y1={y}
                              x2={graphWidth}
                              y2={y}
                              stroke="#e2e8f0"
                              strokeWidth={1}
                              strokeDasharray="4,4"
                            />
                            {/* Show score labels for odd numbers (1, 3, 5, 7, 9) and also 10 */}
                            {(score % 2 === 1 || score === 10) && (
                              <text
                                x={-20}
                                y={y + 4}
                                textAnchor="middle"
                                className="text-xs fill-gray-600 font-medium"
                              >
                                {score}
                              </text>
                            )}
                          </g>
                        );
                      })}
                    </svg>

                    {/* Axis Labels */}
                    <div className="absolute -left-16 top-1/2 transform -translate-y-1/2 -rotate-90 text-sm font-semibold text-gray-700" style={{ zIndex: 2 }}>
                      Impact ‚Üí
                    </div>
                    <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-8 text-sm font-semibold text-gray-700" style={{ zIndex: 2 }}>
                      Feasibility ‚Üí
                    </div>
                  </div>
                </div>

                <svg className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ zIndex: 1 }}>
                  {renderStructureConnections()}
                </svg>

                {selectedNodes.map(node => {
                  const analysis = hierarchyAnalysis.analysis.find(a => a.nodeId === node.id);
                  if (!analysis) return null;

                  const pos = getStructuredPosition(node);
                  const size = getNodeSize(analysis.impact, analysis.feasibility);
                  const color = getQuadrantColor(analysis.impact, analysis.feasibility);
                  const isSelected = selectedStructureNode === node.id;

                  return (
                    <CircleNode
                      key={`${node.id}-${structureModeKey}`}
                      node={node}
                      pos={pos}
                      size={size}
                      color={color}
                      isSelected={isSelected}
                      onSelect={() => setSelectedStructureNode(node.id)}
                      onMouseDown={(e, node) => {
                        // Structure mode: enable dragging and select the node
                        e.preventDefault();
                        e.stopPropagation();

                        // Select the node immediately when mouse down (for info display)
                        setSelectedStructureNode(node.id);

                        // Get the actual rendered position of the node (screen coordinates)
                        // Use the actual DOM element's position, not the calculated position
                        const nodeElement = e.currentTarget;
                        const nodeRect = nodeElement.getBoundingClientRect();
                        const nodeCenterX = nodeRect.left + nodeRect.width / 2;
                        const nodeCenterY = nodeRect.top + nodeRect.height / 2;

                        // Calculate offset from actual rendered node center to mouse position
                        // This ensures drag starts from where the node is actually displayed
                        const offsetX = e.clientX - nodeCenterX;
                        const offsetY = e.clientY - nodeCenterY;

                        // Also update the structureGridPositions to match the actual rendered position
                        // This ensures future drags start from the correct position
                        const graphContainer = document.getElementById('structure-graph-container');
                        if (graphContainer) {
                          const graphRect = graphContainer.getBoundingClientRect();
                          // Convert screen coordinates to graph container relative coordinates
                          const graphRelativeX = nodeCenterX - graphRect.left;
                          const graphRelativeY = nodeCenterY - graphRect.top;

                          // CRITICAL: Update structureGridPositions with the ACTUAL rendered position
                          // This ensures getStructuredPosition will use the correct position next render
                          setStructureGridPositions(prev => ({
                            ...prev,
                            [node.id]: { x: graphRelativeX, y: graphRelativeY }
                          }));

                          // Also update the node's stored position to match the actual rendered position
                          setNodes(prev => prev.map(n =>
                            n.id === node.id
                              ? { ...n, x: graphRelativeX, y: graphRelativeY, structurePositioned: true }
                              : n
                          ));
                        }

                        // Store initial position (impact/feasibility) for quadrant comparison
                        const currentAnalysis = hierarchyAnalysis?.analysis.find(a => a.nodeId === node.id);
                        if (currentAnalysis) {
                          setNodeInitialPosition({
                            impact: currentAnalysis.impact,
                            feasibility: currentAnalysis.feasibility
                          });
                        }

                        setDragOffset({ x: offsetX, y: offsetY });
                        setDraggingNode(node.id);
                        setMouseDownPos({ x: e.clientX, y: e.clientY });
                      }}
                      onClick={(e) => {
                        // Also handle click for selection (backup in case onMouseDown doesn't fire)
                        e.preventDefault();
                        e.stopPropagation();
                        setSelectedStructureNode(node.id);
                      }}
                    />
                  );
                })}
              </>
            )}
          </div>

          <div className="w-96 bg-white border-l border-gray-200 overflow-y-auto p-4 flex flex-col">
            {!selectedStructureNode ? (
              <div className="flex flex-col items-center justify-center flex-1 text-gray-400">
                <Lightbulb size={64} className="mb-4 opacity-30" />
                <p className="text-sm text-center">Select an idea to view details</p>
              </div>
            ) : (() => {
              const selectedNode = selectedNodes.find(n => n.id === selectedStructureNode);
              const analysis = hierarchyAnalysis?.analysis.find(a => a.nodeId === selectedStructureNode);

              if (!selectedNode || !analysis) return null;

              const isHighImpact = analysis.impact > 5;
              const isHighFeasibility = analysis.feasibility > 5;

              let quadrantLabel = 'Maybe Later';
              let quadrantColor = '#9ca3af';

              if (isHighImpact && isHighFeasibility) {
                quadrantLabel = 'Quick Wins';
                quadrantColor = '#10b981';
              } else if (isHighImpact && !isHighFeasibility) {
                quadrantLabel = 'Big Bets';
                quadrantColor = '#f59e0b';
              } else if (!isHighImpact && isHighFeasibility) {
                quadrantLabel = 'Fill-ins';
                quadrantColor = '#3b82f6';
              }

              return (
                <div className="space-y-4 flex-1">
                  {/* Header */}
                  <div className="flex items-start gap-3">
                    <div className="p-3 bg-purple-100 rounded-lg">
                      <Lightbulb size={24} className="text-purple-600" />
                    </div>
                    <div className="flex-1">
                      <h2 className="text-lg font-bold text-gray-800">Design Opportunity Details</h2>
                    </div>
                  </div>

                  {/* Idea Description */}
                  <div>
                    <p className="text-gray-700 leading-relaxed">{selectedNode.text}</p>
                  </div>

                  {/* Quadrant Badge */}
                  <div>
                    <span
                      className="inline-block px-4 py-2 rounded-full text-white font-semibold text-sm"
                      style={{ backgroundColor: quadrantColor }}
                    >
                      {quadrantLabel}
                    </span>
                  </div>

                  {/* Impact Score */}
                  <div>
                    <h3 className="text-sm font-semibold text-gray-600 mb-2">Impact Score</h3>
                    <div className="flex items-center gap-3">
                      <div className="flex-1 h-3 bg-gray-200 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-purple-600 transition-all"
                          style={{ width: `${(analysis.impact / 10) * 100}%` }}
                        />
                      </div>
                      <span className="text-2xl font-bold text-gray-800 w-12 text-right">{analysis.impact.toFixed(1)}</span>
                    </div>
                  </div>

                  {/* Feasibility Score */}
                  <div>
                    <h3 className="text-sm font-semibold text-gray-600 mb-2">Feasibility Score</h3>
                    <div className="flex items-center gap-3">
                      <div className="flex-1 h-3 bg-gray-200 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-purple-600 transition-all"
                          style={{ width: `${(analysis.feasibility / 10) * 100}%` }}
                        />
                      </div>
                      <span className="text-2xl font-bold text-gray-800 w-12 text-right">{analysis.feasibility.toFixed(1)}</span>
                    </div>
                  </div>

                  {/* Insight Section */}
                  {analysis.insight && (
                    <div className="bg-blue-50 rounded-lg p-4 border border-blue-200">
                      <div className="flex items-center gap-2 mb-2">
                        <div className="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center">
                          <span className="text-white text-xs font-bold">‚Ñπ</span>
                        </div>
                        <h3 className="font-semibold text-blue-900">Analysis</h3>
                      </div>
                      <p className="text-sm text-blue-800 leading-relaxed">{analysis.insight}</p>
                    </div>
                  )}

                  {/* Category */}
                  <div>
                    <span className={`inline-block px-3 py-1 rounded-full text-xs font-semibold ${getCategoryColor(analysis.category)}`}>
                      {analysis.category}
                    </span>
                  </div>
                </div>
              );
            })()}

            {/* Creative Flow Timeline - Always shown at bottom of sidebar */}
            {creativityHistory.length > 0 && (
              <div className="mt-auto pt-4">
                <div className="bg-white rounded-lg shadow-lg border border-gray-200 p-4">
                  <div className="mb-3">
                    <h3 className="text-lg font-bold text-gray-800">Creative Flow Timeline</h3>
                    <p className="text-xs text-gray-600 mt-1">Watch your creativity journey unfold! üé®</p>
                  </div>

                  <div className="relative h-32 bg-gray-50 rounded-lg mb-3 overflow-hidden">
                    <svg className="w-full h-full" viewBox="0 0 200 100" preserveAspectRatio="xMidYMid meet">
                      {/* Background grid lines for better visualization */}
                      <defs>
                        <pattern id="grid-structure" width="10" height="10" patternUnits="userSpaceOnUse">
                          <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#e5e7eb" strokeWidth="0.5" opacity="0.5" />
                        </pattern>
                      </defs>
                      <rect x="0" y="0" width="200" height="100" fill="url(#grid-structure)" />

                      {/* Calculate X positions to fill the box */}
                      {(() => {
                        const pointCount = creativityHistory.length;
                        const getXPosition = (index) => {
                          if (pointCount === 0) return 100;
                          if (pointCount === 1) return 100; // Center for single point
                          // For 2+ points, use full width of the rect (0 to 200)
                          const minX = 0;
                          const maxX = 200;
                          return minX + (index / (pointCount - 1)) * (maxX - minX);
                        };

                        return (
                          <>
                            {/* Creativity line (green) */}
                            <polyline
                              points={creativityHistory.map((metrics, index) => {
                                const x = getXPosition(index);
                                const creativity = typeof metrics === 'object' ? metrics.creativity : (typeof metrics === 'number' ? metrics : 0);
                                const y = 90 - (creativity * 80);
                                return `${x},${y}`;
                              }).join(' ')}
                              fill="none"
                              stroke="#10b981"
                              strokeWidth="2.5"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              className="transition-all duration-700 ease-out"
                            />
                            {creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const creativity = typeof metrics === 'object' ? metrics.creativity : (typeof metrics === 'number' ? metrics : 0);
                              const y = 90 - (creativity * 80);
                              const isLast = index === creativityHistory.length - 1;
                              return (
                                <g key={`creativity-structure-${index}`} className="transition-all duration-700 ease-out">
                                  <circle
                                    cx={x}
                                    cy={y}
                                    r={isLast ? "3.5" : "3.5"}
                                    fill="#10b981"
                                    stroke="white"
                                    strokeWidth="2"
                                    opacity="0.9"
                                    className={isLast ? "animate-pulse" : ""}
                                    style={{
                                      transition: 'all 0.7s cubic-bezier(0.4, 0, 0.2, 1)'
                                    }}
                                  >
                                    {isLast && (
                                      <animate
                                        attributeName="r"
                                        values="3.5;5;3.5"
                                        dur="0.6s"
                                        repeatCount="1"
                                      />
                                    )}
                                  </circle>
                                </g>
                              );
                            })}

                            {/* Dependency line (orange) */}
                            <polyline
                              points={creativityHistory.map((metrics, index) => {
                                const x = getXPosition(index);
                                const dependency = typeof metrics === 'object' ? metrics.dependency : 0;
                                const y = 90 - (dependency * 80);
                                return `${x},${y}`;
                              }).join(' ')}
                              fill="none"
                              stroke="#f97316"
                              strokeWidth="2.5"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              className="transition-all duration-700 ease-out"
                            />
                            {creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const dependency = typeof metrics === 'object' ? metrics.dependency : 0;
                              const y = 90 - (dependency * 80);
                              const isLast = index === creativityHistory.length - 1;
                              return (
                                <g key={`dependency-structure-${index}`} className="transition-all duration-700 ease-out">
                                  <circle
                                    cx={x}
                                    cy={y}
                                    r="3.5"
                                    fill="#f97316"
                                    stroke="white"
                                    strokeWidth="2"
                                    opacity="0.9"
                                    className={isLast ? "animate-pulse" : ""}
                                    style={{
                                      transition: 'all 0.7s cubic-bezier(0.4, 0, 0.2, 1)'
                                    }}
                                  >
                                    {isLast && (
                                      <animate
                                        attributeName="r"
                                        values="3.5;5;3.5"
                                        dur="0.6s"
                                        begin="0.1s"
                                        repeatCount="1"
                                      />
                                    )}
                                  </circle>
                                </g>
                              );
                            })}
                          </>
                        );
                      })()}
                    </svg>
                  </div>

                  {/* Legend and Metrics */}
                  <div className="flex items-center justify-between mt-3 relative">
                    <div className="flex items-center gap-4">
                      <div className="flex items-center gap-2">
                        <div className="w-8 h-1 bg-green-500 rounded"></div>
                        <span className="text-xs text-gray-700">Creativity</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <div className="w-8 h-1 bg-orange-500 rounded"></div>
                        <span className="text-xs text-gray-700">Dependency</span>
                      </div>
                    </div>
                    <div className="flex items-center gap-3">
                      <div className="flex items-center gap-1 text-sm font-semibold text-gray-700">
                        <span className="text-green-500">‚Üë</span>
                        <span>{Math.round(currentCreativity * 100)}%</span>
                      </div>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          setCurrentPage('report');
                          setActiveTab('timeline');
                        }}
                        className="text-gray-400 hover:text-gray-600 p-1.5 rounded hover:bg-gray-100 transition-colors"
                        title="View Details"
                      >
                        <Maximize2 size={18} />
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>

      </div>
    );
  }

  // Creativity Report Page
  if (currentPage === 'report') {
    return (
      <div className="w-full h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col">
        <div className="bg-white shadow-sm p-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <div className="flex items-center gap-2 mb-2">
                <button
                  onClick={() => setCurrentPage('main')}
                  className="text-gray-600 hover:text-gray-800 text-sm flex items-center gap-1"
                >
                  <ArrowLeft size={16} />
                  Back to Canvas
                </button>
              </div>
              <div className="flex items-center gap-2">
                <h1 className="text-2xl font-bold text-gray-800">
                  {activeTab === 'overview' ? 'Creativity Tracking' : 'Creativity Report'}
                </h1>
                <span className="text-yellow-500">‚òÖ</span>
              </div>
              <p className="text-sm text-gray-600 mt-1">
                {activeTab === 'overview'
                  ? 'Analyze your creative process using Semantic Space dimensions and track Human-AI collaboration patterns.'
                  : 'Analyze your creative process using Semantic Space dimensions and track Human-AI collaboration patterns.'}
              </p>
            </div>
          </div>

          {/* Tabs */}
          <div className="flex gap-2 border-b border-gray-200">
            <button
              onClick={() => setActiveTab('overview')}
              className={`px-6 py-2 text-sm font-medium transition-colors ${activeTab === 'overview'
                ? 'text-purple-600 border-b-2 border-purple-600'
                : 'text-gray-600 hover:text-gray-800'
                }`}
            >
              Process
            </button>
            <button
              onClick={() => setActiveTab('timeline')}
              className={`px-6 py-2 text-sm font-medium transition-colors ${activeTab === 'timeline'
                ? 'text-purple-600 border-b-2 border-purple-600'
                : 'text-gray-600 hover:text-gray-800'
                }`}
            >
              Outcome
            </button>
          </div>
        </div>

        <div className="flex-1 overflow-auto p-6">
          {/* Process Tab (formerly Overview) */}
          {activeTab === 'overview' && (() => {
            // Calculate Semantic Space scores from event history
            const calculateSemanticScores = (actor) => {
              const events = eventHistory.filter(e => e.actor === actor);
              if (events.length === 0) {
                return {
                  reframing: 0,
                  conceptualBlending: 0,
                  domainKnowledge: 0,
                  evaluation: 0,
                  constraintSetting: 0,
                  generationExpansion: 0
                };
              }

              // Aggregate scores from events (each event can have 0-3 points per dimension)
              const totalReframing = events.reduce((sum, e) => sum + ((e as any).semantic_reframing_score || 0), 0);
              const totalBlending = events.reduce((sum, e) => sum + ((e as any).semantic_blending_score || 0), 0);
              const totalDomain = events.reduce((sum, e) => sum + ((e as any).semantic_domain_score || 0), 0);
              const totalEvaluation = events.reduce((sum, e) => sum + ((e as any).semantic_evaluation_score || 0), 0);
              const totalConstraint = events.reduce((sum, e) => sum + ((e as any).semantic_constraint_score || 0), 0);
              const totalGenerative = events.reduce((sum, e) => sum + ((e as any).semantic_generative_score || 0), 0);

              // Normalize: Use average score per event (max 3 per event), then normalize to 0-1
              // This gives more meaningful scores even with few events
              const avgReframing = events.length > 0 ? totalReframing / events.length : 0;
              const avgBlending = events.length > 0 ? totalBlending / events.length : 0;
              const avgDomain = events.length > 0 ? totalDomain / events.length : 0;
              const avgEvaluation = events.length > 0 ? totalEvaluation / events.length : 0;
              const avgConstraint = events.length > 0 ? totalConstraint / events.length : 0;
              const avgGenerative = events.length > 0 ? totalGenerative / events.length : 0;

              return {
                reframing: Math.min(avgReframing / 3, 1), // Normalize: avg score (0-3) / 3 = 0-1
                conceptualBlending: Math.min(avgBlending / 3, 1),
                domainKnowledge: Math.min(avgDomain / 3, 1),
                evaluation: Math.min(avgEvaluation / 3, 1),
                constraintSetting: Math.min(avgConstraint / 3, 1),
                generationExpansion: Math.min(avgGenerative / 3, 1)
              };
            };

            // Calculate scores for AI and Human
            const aiScores = calculateSemanticScores('AI');
            const humanScores = calculateSemanticScores('HUMAN');

            // Determine strengths for 6 dimensions
            const getStrengths = (scores) => {
              const strengths = [];
              if (scores.reframing > 0.7) strengths.push('Reframing');
              if (scores.conceptualBlending > 0.7) strengths.push('Conceptual Blending');
              if (scores.domainKnowledge > 0.7) strengths.push('Domain Knowledge');
              if (scores.evaluation > 0.7) strengths.push('Evaluation');
              if (scores.constraintSetting > 0.7) strengths.push('Constraint Setting');
              if (scores.generationExpansion > 0.7) strengths.push('Generation Expansion');
              return strengths.length > 0 ? strengths.join(' & ') : 'Balanced';
            };

            const aiStrengths = getStrengths(aiScores);
            const humanStrengths = getStrengths(humanScores);

            // Generate collaboration pattern insight
            const generateCollaborationInsight = () => {
              const humanTotal = Object.values(humanScores).reduce((a, b) => a + b, 0);
              const aiTotal = Object.values(aiScores).reduce((a, b) => a + b, 0);

              if (humanTotal > aiTotal * 1.2) {
                return "Human-Led Exploration ‚Üí AI-Assisted Refinement";
              } else if (aiTotal > humanTotal * 1.2) {
                return "AI-Led Exploration ‚Üí Human-Led Structure";
              } else {
                return "Balanced Co-Creation";
              }
            };

            return (
              <div className="space-y-8">
                {/* Two Column Layout */}
                <div className="grid grid-cols-2 gap-6">
                  {/* Left: Co-Creative Competence Distribution - Radar Chart */}
                  <div className="bg-white rounded-lg p-6 shadow-md border border-gray-200">
                    <h3 className="text-lg font-bold text-gray-800 mb-8">Co-Creative Competence Distribution</h3>
                    <div className="flex items-center justify-center overflow-visible my-8">
                      <svg width="400" height="400" viewBox="0 0 400 400" style={{ overflow: 'visible' }}>
                        {/* Grid circles */}
                        {[25, 50, 75, 100].map((radius) => (
                          <circle
                            key={radius}
                            cx="200"
                            cy="200"
                            r={radius * 1.5}
                            fill="none"
                            stroke="#e5e7eb"
                            strokeWidth="1"
                            strokeDasharray="2,2"
                          />
                        ))}

                        {/* Axes - 6 axes evenly distributed (60 degrees apart) */}
                        {[
                          { label: 'Reframing', angle: -90 },
                          { label: 'Conceptual Blending', angle: -30 },
                          { label: 'Domain knowledge', angle: 30 },
                          { label: 'Evaluation', angle: 90 },
                          { label: 'Constraint Setting', angle: 150 },
                          { label: 'Generation Expansion', angle: -150 }
                        ].map((axis, idx) => {
                          const angle = (axis.angle * Math.PI) / 180;
                          const centerX = 200;
                          const centerY = 200;
                          const axisLength = 150;
                          const x = centerX + axisLength * Math.cos(angle);
                          const y = centerY + axisLength * Math.sin(angle);

                          // Calculate label position (further out from axis end)
                          const labelDistance = 30; // Distance from axis end
                          const labelX = centerX + (axisLength + labelDistance) * Math.cos(angle);
                          const labelY = centerY + (axisLength + labelDistance) * Math.sin(angle);

                          return (
                            <g key={axis.label}>
                              <line
                                x1={centerX}
                                y1={centerY}
                                x2={x}
                                y2={y}
                                stroke="#d1d5db"
                                strokeWidth="1"
                              />
                              {/* Text with background for visibility */}
                              <g>
                                {/* Background rectangle for text */}
                                <rect
                                  x={labelX - (axis.label.length * 3.5)}
                                  y={labelY - 8}
                                  width={axis.label.length * 7}
                                  height={16}
                                  fill="white"
                                  fillOpacity="0.9"
                                  stroke="none"
                                  rx="2"
                                />
                                <text
                                  x={labelX}
                                  y={labelY + 4}
                                  fontSize="11"
                                  fill="#374151"
                                  textAnchor="middle"
                                  fontWeight="600"
                                  style={{ pointerEvents: 'none' }}
                                >
                                  {axis.label}
                                </text>
                              </g>
                            </g>
                          );
                        })}

                        {/* AI Polygon (orange) */}
                        <polygon
                          points={[
                            `${200 + aiScores.reframing * 150 * Math.cos(-90 * Math.PI / 180)},${200 + aiScores.reframing * 150 * Math.sin(-90 * Math.PI / 180)}`,
                            `${200 + aiScores.conceptualBlending * 150 * Math.cos(-30 * Math.PI / 180)},${200 + aiScores.conceptualBlending * 150 * Math.sin(-30 * Math.PI / 180)}`,
                            `${200 + aiScores.domainKnowledge * 150 * Math.cos(30 * Math.PI / 180)},${200 + aiScores.domainKnowledge * 150 * Math.sin(30 * Math.PI / 180)}`,
                            `${200 + aiScores.evaluation * 150 * Math.cos(90 * Math.PI / 180)},${200 + aiScores.evaluation * 150 * Math.sin(90 * Math.PI / 180)}`,
                            `${200 + aiScores.constraintSetting * 150 * Math.cos(150 * Math.PI / 180)},${200 + aiScores.constraintSetting * 150 * Math.sin(150 * Math.PI / 180)}`,
                            `${200 + aiScores.generationExpansion * 150 * Math.cos(-150 * Math.PI / 180)},${200 + aiScores.generationExpansion * 150 * Math.sin(-150 * Math.PI / 180)}`
                          ].join(' ')}
                          fill="#f97316"
                          fillOpacity="0.3"
                          stroke="#f97316"
                          strokeWidth="2"
                        />

                        {/* Human Polygon (purple) */}
                        {eventHistory.some(e => e.actor === 'HUMAN') && (
                          <polygon
                            points={[
                              `${200 + humanScores.reframing * 150 * Math.cos(-90 * Math.PI / 180)},${200 + humanScores.reframing * 150 * Math.sin(-90 * Math.PI / 180)}`,
                              `${200 + humanScores.conceptualBlending * 150 * Math.cos(-30 * Math.PI / 180)},${200 + humanScores.conceptualBlending * 150 * Math.sin(-30 * Math.PI / 180)}`,
                              `${200 + humanScores.domainKnowledge * 150 * Math.cos(30 * Math.PI / 180)},${200 + humanScores.domainKnowledge * 150 * Math.sin(30 * Math.PI / 180)}`,
                              `${200 + humanScores.evaluation * 150 * Math.cos(90 * Math.PI / 180)},${200 + humanScores.evaluation * 150 * Math.sin(90 * Math.PI / 180)}`,
                              `${200 + humanScores.constraintSetting * 150 * Math.cos(150 * Math.PI / 180)},${200 + humanScores.constraintSetting * 150 * Math.sin(150 * Math.PI / 180)}`,
                              `${200 + humanScores.generationExpansion * 150 * Math.cos(-150 * Math.PI / 180)},${200 + humanScores.generationExpansion * 150 * Math.sin(-150 * Math.PI / 180)}`
                            ].join(' ')}
                            fill="#8b5cf6"
                            fillOpacity="0.3"
                            stroke="#8b5cf6"
                            strokeWidth="2"
                          />
                        )}
                      </svg>
                    </div>
                    <div className="flex items-center justify-center gap-4 mt-12">
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 rounded bg-orange-500"></div>
                        <span className="text-sm text-gray-700">AI</span>
                      </div>
                      {eventHistory.some(e => e.actor === 'HUMAN') && (
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-4 rounded bg-purple-500"></div>
                          <span className="text-sm text-gray-700">Human</span>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Right: Collaboration Patterns */}
                  <div className="bg-white rounded-lg p-6 shadow-md border border-gray-200">
                    <h3 className="text-lg font-bold text-gray-800 mb-4">Collaboration Patterns</h3>
                    <div className="flex flex-col items-center justify-center h-80">
                      {/* Network/Graph Icon */}
                      <div className="w-32 h-32 bg-purple-100 rounded-lg flex items-center justify-center mb-6">
                        <svg width="80" height="80" viewBox="0 0 100 100" className="text-purple-600">
                          {/* Simple network graph icon */}
                          <circle cx="30" cy="30" r="8" fill="currentColor" />
                          <circle cx="70" cy="30" r="8" fill="currentColor" />
                          <circle cx="50" cy="70" r="8" fill="currentColor" />
                          <line x1="30" y1="30" x2="50" y2="70" stroke="currentColor" strokeWidth="2" />
                          <line x1="70" y1="30" x2="50" y2="70" stroke="currentColor" strokeWidth="2" />
                          <line x1="30" y1="30" x2="70" y2="30" stroke="currentColor" strokeWidth="2" />
                        </svg>
                      </div>
                      <p className="text-lg font-semibold text-gray-800 mb-4 text-center">
                        {generateCollaborationInsight()}
                      </p>
                      <div className="bg-purple-50 rounded-lg p-4 w-full">
                        <p className="text-sm font-semibold text-gray-700 mb-2">Insight:</p>
                        <p className="text-sm text-gray-600">
                          {humanScores.evaluation > aiScores.evaluation && humanScores.constraintSetting > aiScores.constraintSetting
                            ? "Your evaluation and constraint setting scores are higher than AI contributions, indicating strong decision-making and focus."
                            : aiScores.reframing > humanScores.reframing && aiScores.conceptualBlending > humanScores.conceptualBlending
                              ? "AI contributions excel in reframing and conceptual blending, providing diverse perspectives and novel connections."
                              : "Your creative process shows a balanced collaboration between human insight and AI assistance."}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Creative Flow Timeline Graph - Large version for Process tab */}
                <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                  <div className="mb-4">
                    <h3 className="text-xl font-bold text-gray-800 mb-2">Creative Flow Timeline</h3>
                    <p className="text-sm text-gray-600">Track your creativity and dependency scores over time</p>
                  </div>
                  <div className="border-t border-gray-200 pt-4">
                    {/* Mode labels - above graph */}
                    {(() => {
                      const structureModeStartIndex = hierarchyAnalysis?.structureModeStartIndex ?? null;
                      const pointCount = creativityHistory.length;
                      const hasStructureMode = structureModeStartIndex !== null && structureModeStartIndex < pointCount;
                      const getXPosition = (index) => {
                        if (pointCount === 0) return 100;
                        if (pointCount === 1) return 100;
                        const minX = 0;
                        const maxX = 200;
                        return minX + (index / (pointCount - 1)) * (maxX - minX);
                      };
                      const modeDivisionX = hasStructureMode && pointCount > 1
                        ? getXPosition(structureModeStartIndex)
                        : null;

                      // Calculate percentage for positioning
                      const modeDivisionPercent = modeDivisionX !== null ? (modeDivisionX / 200) * 100 : 0;

                      return (
                        <div className="relative mb-2 h-6">
                          {hasStructureMode && modeDivisionX !== null ? (
                            <>
                              <div className="absolute left-0 flex items-center gap-2" style={{ width: `${modeDivisionPercent}%` }}>
                                <div className="w-4 h-4 rounded bg-purple-500/20 border border-purple-500/40 flex items-center justify-center">
                                  <svg className="w-3 h-3 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                  </svg>
                                </div>
                                <span className="text-xs font-semibold text-purple-600">Exploration Mode</span>
                              </div>
                              <div className="absolute right-0 flex items-center gap-2 justify-end" style={{ width: `${100 - modeDivisionPercent}%` }}>
                                <span className="text-xs font-semibold text-orange-600">Structure Mode</span>
                                <div className="w-4 h-4 rounded bg-orange-500/20 border border-orange-500/40 flex items-center justify-center">
                                  <svg className="w-3 h-3 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                                  </svg>
                                </div>
                              </div>
                            </>
                          ) : (
                            <div className="flex items-center gap-2">
                              <div className="w-4 h-4 rounded bg-purple-500/20 border border-purple-500/40 flex items-center justify-center">
                                <svg className="w-3 h-3 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                              </div>
                              <span className="text-xs font-semibold text-purple-600">Exploration Mode</span>
                            </div>
                          )}
                        </div>
                      );
                    })()}

                    <div className="relative h-[400px] bg-gray-50 rounded-lg overflow-hidden">
                      {/* Y-axis label - outside graph */}
                      <div className="absolute left-0 top-1/2 -translate-y-1/2 -translate-x-12 transform -rotate-90 origin-center">
                        <span className="text-xs font-medium text-gray-600">Score (%)</span>
                      </div>

                      {/* Tooltip */}
                      {hoveredPointIndex !== null && (() => {
                        // Calculate semantic scores up to this point
                        const pointEvents = eventHistory.slice(0, hoveredPointIndex + 1);
                        const calculateSemanticScores = (actor) => {
                          const events = pointEvents.filter(e => e.actor === actor);
                          if (events.length === 0) {
                            return {
                              reframing: 0,
                              conceptualBlending: 0,
                              domainKnowledge: 0,
                              evaluation: 0,
                              constraintSetting: 0,
                              generationExpansion: 0
                            };
                          }
                          const totalReframing = events.reduce((sum, e) => sum + ((e as any).semantic_reframing_score || 0), 0);
                          const totalBlending = events.reduce((sum, e) => sum + ((e as any).semantic_blending_score || 0), 0);
                          const totalDomain = events.reduce((sum, e) => sum + ((e as any).semantic_domain_score || 0), 0);
                          const totalEvaluation = events.reduce((sum, e) => sum + ((e as any).semantic_evaluation_score || 0), 0);
                          const totalConstraint = events.reduce((sum, e) => sum + ((e as any).semantic_constraint_score || 0), 0);
                          const totalGenerative = events.reduce((sum, e) => sum + ((e as any).semantic_generative_score || 0), 0);
                          const avgReframing = events.length > 0 ? totalReframing / events.length : 0;
                          const avgBlending = events.length > 0 ? totalBlending / events.length : 0;
                          const avgDomain = events.length > 0 ? totalDomain / events.length : 0;
                          const avgEvaluation = events.length > 0 ? totalEvaluation / events.length : 0;
                          const avgConstraint = events.length > 0 ? totalConstraint / events.length : 0;
                          const avgGenerative = events.length > 0 ? totalGenerative / events.length : 0;
                          return {
                            reframing: Math.min(avgReframing / 3, 1),
                            conceptualBlending: Math.min(avgBlending / 3, 1),
                            domainKnowledge: Math.min(avgDomain / 3, 1),
                            evaluation: Math.min(avgEvaluation / 3, 1),
                            constraintSetting: Math.min(avgConstraint / 3, 1),
                            generationExpansion: Math.min(avgGenerative / 3, 1)
                          };
                        };
                        const aiScores = calculateSemanticScores('AI');
                        const metrics = creativityHistory[hoveredPointIndex];
                        const humanRatio = typeof metrics === 'object' ? (metrics.curve_human_ratio ?? metrics.creativity ?? 0) : 0;
                        const aiRatio = typeof metrics === 'object' ? (metrics.curve_ai_ratio ?? metrics.dependency ?? 0) : 0;
                        const aiScoreTotal = typeof metrics === 'object' ? (metrics.ai_score_total ?? 0) : 0;
                        const humanScoreTotal = typeof metrics === 'object' ? (metrics.human_score_total ?? 0) : 0;
                        const totalScore = aiScoreTotal + humanScoreTotal;
                        // Calculate tooltip position to stay within bounds
                        const tooltipWidth = 280;
                        const tooltipHeight = 200;
                        const containerHeight = 400;
                        const margin = 10;

                        // Check if tooltip should be above or below the point
                        const showAbove = tooltipPosition.y > tooltipHeight + margin + 20;

                        // Get container width for X position calculation
                        const containerElement = document.querySelector('.relative.h-\\[400px\\]');
                        const containerWidth = containerElement?.getBoundingClientRect().width || 800;

                        // Calculate X position (clamp to container bounds)
                        const tooltipLeft = tooltipPosition.x - tooltipWidth / 2;
                        const tooltipRight = tooltipPosition.x + tooltipWidth / 2;
                        let xPos = tooltipPosition.x;
                        if (tooltipLeft < margin) {
                          xPos = tooltipWidth / 2 + margin;
                        } else if (tooltipRight > containerWidth - margin) {
                          xPos = containerWidth - tooltipWidth / 2 - margin;
                        }

                        // Calculate Y position
                        const yPos = showAbove
                          ? Math.max(margin, tooltipPosition.y - tooltipHeight - margin)
                          : Math.min(tooltipPosition.y + 20, containerHeight - tooltipHeight - margin);

                        return (
                          <div
                            className="absolute bg-white rounded-lg shadow-lg border border-gray-200 p-4 z-50 pointer-events-none"
                            style={{
                              left: `${xPos}px`,
                              top: `${yPos}px`,
                              transform: 'translateX(-50%)',
                              maxWidth: '280px',
                              width: '280px'
                            }}
                          >
                            <div className="flex items-center justify-between mb-3">
                              <div className="flex items-center gap-2">
                                <div className="w-6 h-6 rounded bg-orange-500 flex items-center justify-center">
                                  <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                                  </svg>
                                </div>
                              </div>
                            </div>
                            <div className="text-xs text-gray-600 mb-2">
                              <div className="flex items-center gap-2 mb-1">
                                <span className="font-semibold text-orange-600">Ratio:</span>
                                <span>Human: {(humanRatio * 100).toFixed(0)}% / AI: {(aiRatio * 100).toFixed(0)}%</span>
                              </div>
                              <div className="flex items-center gap-2">
                                <span className="font-semibold text-orange-600">Total AI Score:</span>
                                <span>{aiScoreTotal.toFixed(1)}</span>
                              </div>
                            </div>
                            <div className="text-xs text-gray-600 mb-2">
                              <span className="font-semibold">Framework Name:</span>
                              <span className="ml-2">Co-Creative Competence</span>
                            </div>
                            <div className="grid grid-cols-2 gap-2 text-xs">
                              <div>
                                <div className="text-gray-700">Generation Expansion: {(aiScores.generationExpansion * 100).toFixed(0)}%</div>
                                <div className="text-gray-700">Conceptual Blending: {(aiScores.conceptualBlending * 100).toFixed(0)}%</div>
                                <div className="text-gray-700">Constraint Setting: {(aiScores.constraintSetting * 100).toFixed(0)}%</div>
                              </div>
                              <div>
                                <div className="text-gray-700">Reframing: {(aiScores.reframing * 100).toFixed(0)}%</div>
                                <div className="text-gray-700">Evaluation: {(aiScores.evaluation * 100).toFixed(0)}%</div>
                                <div className="text-gray-700">Domain Knowledge: {(aiScores.domainKnowledge * 100).toFixed(0)}%</div>
                              </div>
                            </div>
                          </div>
                        );
                      })()}

                      <svg className="w-full h-full" viewBox="-25 0 325 100" preserveAspectRatio="xMidYMid meet">
                        {/* Background gradients */}
                        <defs>
                          {/* Gradient for Human area */}
                          <linearGradient id="humanGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#8b5cf6" stopOpacity="0.3" />
                            <stop offset="100%" stopColor="#8b5cf6" stopOpacity="0.05" />
                          </linearGradient>
                          {/* Gradient for AI area */}
                          <linearGradient id="aiGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#f97316" stopOpacity="0.3" />
                            <stop offset="100%" stopColor="#f97316" stopOpacity="0.05" />
                          </linearGradient>
                        </defs>
                        <rect x="0" y="0" width="300" height="100" fill="transparent" />

                        {/* Calculate X positions to fill the box */}
                        {(() => {
                          const pointCount = creativityHistory.length;
                          const getXPosition = (index) => {
                            if (pointCount === 0) return 150;
                            if (pointCount === 1) return 150;
                            const minX = 0;
                            const maxX = 300;
                            return minX + (index / (pointCount - 1)) * (maxX - minX);
                          };

                          // Determine Structure Mode start index
                          const structureModeStartIndex = hierarchyAnalysis?.structureModeStartIndex ?? null;
                          const hasStructureMode = structureModeStartIndex !== null && structureModeStartIndex < pointCount;

                          // Calculate mode division point
                          const modeDivisionX = hasStructureMode && pointCount > 1
                            ? getXPosition(structureModeStartIndex)
                            : null;

                          // Generate smooth curve paths using cubic bezier curves
                          const getSmoothPath = (points) => {
                            if (points.length < 2) return '';
                            if (points.length === 2) {
                              return `M ${points[0].x},${points[0].y} L ${points[1].x},${points[1].y}`;
                            }

                            let path = `M ${points[0].x},${points[0].y}`;

                            for (let i = 0; i < points.length - 1; i++) {
                              const current = points[i];
                              const next = points[i + 1];

                              // Calculate control points for smooth curve
                              let cp1x, cp1y, cp2x, cp2y;

                              if (i === 0) {
                                // First segment: use current point and next point
                                const dx = (next.x - current.x) / 3;
                                const dy = (next.y - current.y) / 3;
                                cp1x = current.x + dx;
                                cp1y = current.y + dy;
                                cp2x = next.x - dx;
                                cp2y = next.y - dy;
                              } else if (i === points.length - 2) {
                                // Last segment
                                const prev = points[i - 1];
                                const dx = (next.x - prev.x) / 6;
                                const dy = (next.y - prev.y) / 6;
                                cp1x = current.x + dx;
                                cp1y = current.y + dy;
                                cp2x = next.x - dx;
                                cp2y = next.y - dy;
                              } else {
                                // Middle segments: use previous and next points for smoothness
                                const prev = points[i - 1];
                                const after = points[i + 2];
                                const dx1 = (next.x - prev.x) / 6;
                                const dy1 = (next.y - prev.y) / 6;
                                const dx2 = (after.x - current.x) / 6;
                                const dy2 = (after.y - current.y) / 6;
                                cp1x = current.x + dx1;
                                cp1y = current.y + dy1;
                                cp2x = next.x - dx2;
                                cp2y = next.y - dy2;
                              }

                              path += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${next.x},${next.y}`;
                            }

                            return path;
                          };

                          // Generate area paths for gradient fills (smooth curves)
                          const getHumanAreaPath = () => {
                            if (pointCount === 0) return '';
                            const points = creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const humanScore = typeof metrics === 'object'
                                ? (metrics.curve_human_ratio ?? metrics.creativity ?? 0)
                                : 0;
                              const y = 90 - (humanScore * 80);
                              return { x, y };
                            });
                            const firstX = getXPosition(0);
                            const lastX = getXPosition(pointCount - 1);
                            const smoothPath = getSmoothPath(points);
                            return `${smoothPath} L ${lastX},90 L ${firstX},90 Z`;
                          };

                          const getAIAreaPath = () => {
                            if (pointCount === 0) return '';
                            const points = creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const aiScore = typeof metrics === 'object'
                                ? (metrics.curve_ai_ratio ?? metrics.dependency ?? 0)
                                : 0;
                              const y = 90 - (aiScore * 80);
                              return { x, y };
                            });
                            const firstX = getXPosition(0);
                            const lastX = getXPosition(pointCount - 1);
                            const smoothPath = getSmoothPath(points);
                            return `${smoothPath} L ${lastX},90 L ${firstX},90 Z`;
                          };

                          // Generate smooth line path
                          const getHumanLinePath = () => {
                            if (pointCount === 0) return '';
                            const points = creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const humanScore = typeof metrics === 'object'
                                ? (metrics.curve_human_ratio ?? metrics.creativity ?? 0)
                                : 0;
                              const y = 90 - (humanScore * 80);
                              return { x, y };
                            });
                            return getSmoothPath(points);
                          };

                          const getAILinePath = () => {
                            if (pointCount === 0) return '';
                            const points = creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const aiScore = typeof metrics === 'object'
                                ? (metrics.curve_ai_ratio ?? metrics.dependency ?? 0)
                                : 0;
                              const y = 90 - (aiScore * 80);
                              return { x, y };
                            });
                            return getSmoothPath(points);
                          };

                          // Y-axis tick marks and labels
                          const yAxisTicks = [0, 0.25, 0.5, 0.75, 1];

                          // Calculate X-axis time labels
                          const getTimeLabels = () => {
                            if (eventHistory.length === 0 || pointCount === 0) {
                              // Fallback: show labels at start, middle, end
                              if (pointCount === 0) return [];
                              if (pointCount === 1) return [{ index: 0, minutes: 0, x: getXPosition(0) }];
                              return [
                                { index: 0, minutes: 0, x: getXPosition(0) },
                                { index: Math.floor(pointCount / 2), minutes: Math.floor(pointCount * 7.5), x: getXPosition(Math.floor(pointCount / 2)) },
                                { index: pointCount - 1, minutes: Math.floor(pointCount * 15), x: getXPosition(pointCount - 1) }
                              ];
                            }

                            // Get timestamps for each creativityHistory entry
                            const timestamps = [];
                            let eventIndex = 0;
                            for (let i = 0; i < pointCount; i++) {
                              if (i === 0) {
                                timestamps.push(eventHistory[0]?.timestamp || new Date().toISOString());
                              } else {
                                const eventsPerEntry = Math.max(1, Math.floor(eventHistory.length / pointCount));
                                eventIndex = Math.min(eventIndex + eventsPerEntry, eventHistory.length - 1);
                                timestamps.push(eventHistory[eventIndex]?.timestamp || new Date().toISOString());
                              }
                            }

                            // Calculate time in minutes from start
                            const startTime = new Date(timestamps[0]);
                            const timeLabels = timestamps.map((ts, idx) => {
                              const time = new Date(ts);
                              const minutes = Math.floor((time.getTime() - startTime.getTime()) / (1000 * 60));
                              return { index: idx, minutes, x: getXPosition(idx) };
                            });

                            // Filter to show only a few labels (start, middle, end, and key points)
                            if (timeLabels.length <= 3) return timeLabels;

                            const filtered = [
                              timeLabels[0], // Start
                              ...(timeLabels.length > 2 ? [timeLabels[Math.floor(timeLabels.length / 2)]] : []), // Middle
                              timeLabels[timeLabels.length - 1] // End
                            ];

                            // Add Structure Mode start point if it exists
                            if (structureModeStartIndex !== null && structureModeStartIndex > 0 && structureModeStartIndex < timeLabels.length) {
                              const structureLabel = timeLabels[structureModeStartIndex];
                              if (!filtered.find(l => l.index === structureLabel.index)) {
                                filtered.push(structureLabel);
                              }
                            }

                            return filtered.sort((a, b) => a.index - b.index);
                          };

                          const timeLabels = getTimeLabels();

                          return (
                            <>
                              {/* Y-axis tick marks and labels */}
                              {yAxisTicks.map((value) => {
                                const y = 90 - (value * 80);
                                return (
                                  <g key={`y-tick-${value}`}>
                                    {/* Tick line */}
                                    <line
                                      x1="0"
                                      y1={y}
                                      x2="4"
                                      y2={y}
                                      stroke="#d1d5db"
                                      strokeWidth="0.8"
                                      opacity="0.5"
                                    />
                                    {/* Label - positioned at SVG left edge */}
                                    <text
                                      x="-10"
                                      y={y + 2.5}
                                      fontSize="5"
                                      fill="#9ca3af"
                                      fontWeight="400"
                                      textAnchor="end"
                                    >
                                      {value.toFixed(2)}
                                    </text>
                                  </g>
                                );
                              })}

                              {/* X-axis time labels */}
                              {timeLabels.map((label, idx) => (
                                <g key={`time-label-${idx}`}>
                                  {/* Tick line */}
                                  <line
                                    x1={label.x}
                                    y1="90"
                                    x2={label.x}
                                    y2="94"
                                    stroke="#d1d5db"
                                    strokeWidth="0.8"
                                    opacity="0.5"
                                  />
                                  {/* Label */}
                                  <text
                                    x={label.x}
                                    y="98"
                                    fontSize="5"
                                    fill="#9ca3af"
                                    fontWeight="400"
                                    textAnchor="middle"
                                  >
                                    {label.minutes}m
                                  </text>
                                </g>
                              ))}

                              {/* Mode division line */}
                              {hasStructureMode && modeDivisionX !== null && (
                                <line
                                  x1={modeDivisionX}
                                  y1="0"
                                  x2={modeDivisionX}
                                  y2="100"
                                  stroke="#f97316"
                                  strokeWidth="1.5"
                                  strokeDasharray="4,4"
                                  opacity="0.6"
                                />
                              )}

                              {/* Gradient area fills - below lines */}
                              {/* Human area (purple gradient) */}
                              {pointCount > 0 && (
                                <path
                                  d={getHumanAreaPath()}
                                  fill="url(#humanGradient)"
                                  className="transition-all duration-700 ease-out"
                                />
                              )}

                              {/* AI area (orange gradient) */}
                              {pointCount > 0 && (
                                <path
                                  d={getAIAreaPath()}
                                  fill="url(#aiGradient)"
                                  className="transition-all duration-700 ease-out"
                                />
                              )}

                              {/* Human line (purple) - smooth curve */}
                              {pointCount > 0 && (
                                <path
                                  d={getHumanLinePath()}
                                  fill="none"
                                  stroke="#8b5cf6"
                                  strokeWidth="1.2"
                                  strokeLinecap="round"
                                  strokeLinejoin="round"
                                  className="transition-all duration-700 ease-out"
                                />
                              )}
                              {creativityHistory.map((metrics, index) => {
                                const x = getXPosition(index);
                                const humanScore = typeof metrics === 'object'
                                  ? (metrics.curve_human_ratio ?? metrics.creativity ?? 0)
                                  : 0;
                                const y = 90 - (humanScore * 80);
                                const isLast = index === creativityHistory.length - 1;
                                const isHovered = hoveredPointIndex === index;
                                return (
                                  <g key={`process-human-${index}`} className="transition-all duration-700 ease-out">
                                    <circle
                                      cx={x}
                                      cy={y}
                                      r={isHovered ? "4" : "2"}
                                      fill="#8b5cf6"
                                      stroke="white"
                                      strokeWidth="0.8"
                                      opacity="0.95"
                                      className={isLast ? "animate-pulse" : ""}
                                      style={{
                                        transition: 'all 0.7s cubic-bezier(0.4, 0, 0.2, 1)',
                                        cursor: 'pointer'
                                      }}
                                      onMouseEnter={(e) => {
                                        const svg = e.currentTarget.ownerSVGElement;
                                        if (svg) {
                                          const svgRect = svg.getBoundingClientRect();
                                          const viewBox = svg.viewBox.baseVal;
                                          const scaleX = svgRect.width / viewBox.width;
                                          const scaleY = svgRect.height / viewBox.height;
                                          // Convert SVG coordinates to pixel coordinates
                                          const pixelX = (x - viewBox.x) * scaleX;
                                          const pixelY = (y - viewBox.y) * scaleY;
                                          setTooltipPosition({
                                            x: pixelX,
                                            y: pixelY
                                          });
                                        }
                                        setHoveredPointIndex(index);
                                      }}
                                      onMouseLeave={() => {
                                        setHoveredPointIndex(null);
                                      }}
                                    >
                                      {isLast && (
                                        <animate
                                          attributeName="r"
                                          values="2;3;2"
                                          dur="0.6s"
                                          repeatCount="1"
                                        />
                                      )}
                                    </circle>
                                  </g>
                                );
                              })}

                              {/* AI line (orange) - smooth curve */}
                              {pointCount > 0 && (
                                <path
                                  d={getAILinePath()}
                                  fill="none"
                                  stroke="#f97316"
                                  strokeWidth="1.2"
                                  strokeLinecap="round"
                                  strokeLinejoin="round"
                                  className="transition-all duration-700 ease-out"
                                />
                              )}
                              {creativityHistory.map((metrics, index) => {
                                const x = getXPosition(index);
                                const aiScore = typeof metrics === 'object'
                                  ? (metrics.curve_ai_ratio ?? metrics.dependency ?? 0)
                                  : 0;
                                const y = 90 - (aiScore * 80);
                                const isLast = index === creativityHistory.length - 1;
                                const isHovered = hoveredPointIndex === index;
                                return (
                                  <g key={`process-ai-${index}`} className="transition-all duration-700 ease-out">
                                    <circle
                                      cx={x}
                                      cy={y}
                                      r={isHovered ? "4" : "2"}
                                      fill="#f97316"
                                      stroke="white"
                                      strokeWidth="0.8"
                                      opacity="0.95"
                                      className={isLast ? "animate-pulse" : ""}
                                      style={{
                                        transition: 'all 0.7s cubic-bezier(0.4, 0, 0.2, 1)',
                                        cursor: 'pointer'
                                      }}
                                      onMouseEnter={(e) => {
                                        const svg = e.currentTarget.ownerSVGElement;
                                        if (svg) {
                                          const svgRect = svg.getBoundingClientRect();
                                          const viewBox = svg.viewBox.baseVal;
                                          const scaleX = svgRect.width / viewBox.width;
                                          const scaleY = svgRect.height / viewBox.height;
                                          // Convert SVG coordinates to pixel coordinates
                                          const pixelX = (x - viewBox.x) * scaleX;
                                          const pixelY = (y - viewBox.y) * scaleY;
                                          setTooltipPosition({
                                            x: pixelX,
                                            y: pixelY
                                          });
                                        }
                                        setHoveredPointIndex(index);
                                      }}
                                      onMouseLeave={() => {
                                        setHoveredPointIndex(null);
                                      }}
                                    >
                                      {isLast && (
                                        <animate
                                          attributeName="r"
                                          values="2;3;2"
                                          dur="0.6s"
                                          begin="0.1s"
                                          repeatCount="1"
                                        />
                                      )}
                                    </circle>
                                  </g>
                                );
                              })}
                            </>
                          );
                        })()}
                      </svg>
                    </div>

                    {/* Legend */}
                    <div className="flex items-center justify-center mt-4">
                      <div className="flex items-center gap-6">
                        <div className="flex items-center gap-2">
                          <div className="w-10 h-1.5 bg-purple-500 rounded"></div>
                          <span className="text-sm text-gray-700 font-medium">Human</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-10 h-1.5 bg-orange-500 rounded"></div>
                          <span className="text-sm text-gray-700 font-medium">AI</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          })()}

          {/* Outcome Tab */}
          {activeTab === 'timeline' && (() => {
            // Calculate TTCT scores based on TTCT + Dependency Framework
            // Formula: CI' = 0.25F + 0.25X + 0.30O + 0.20E ‚Äì 0.20D
            const calculateTTCTScores = (actor) => {
              // Get nodes created by this actor
              const actorEvents = eventHistory.filter(e => e.actor === actor && e.event_type === 'Create Node');
              if (actorEvents.length === 0 && nodes.length === 0) {
                return {
                  fluency: 0,
                  flexibility: 0,
                  originality: 0,
                  elaboration: 0
                };
              }

              // Get nodes created by this actor (from event history)
              const actorNodeIds = new Set(actorEvents.map(e => e.node_id).filter(Boolean));
              const actorNodes = nodes.filter(n => actorNodeIds.has(n.id.toString()) ||
                (actor === 'AI' && !n.edited) || (actor === 'HUMAN' && n.edited));

              if (actorNodes.length === 0) {
                return {
                  fluency: 0,
                  flexibility: 0,
                  originality: 0,
                  elaboration: 0
                };
              }

              // 1. Fluency: number of ideas generated (count, weight 0.25)
              // Normalize: assume max 50 nodes = 100%
              const fluency = Math.min((actorNodes.length / 50) * 100, 100);

              // 2. Flexibility: variety of idea categories (unique types, weight 0.25)
              const uniqueTypes = new Set(actorNodes.map(n => n.type || n.category || 'default'));
              const uniqueCategories = new Set(actorNodes.map(n => n.category).filter(Boolean));
              const totalUnique = uniqueTypes.size + uniqueCategories.size;
              // Normalize: assume max 10 unique types/categories = 100%
              const flexibility = Math.min((totalUnique / 10) * 100, 100);

              // 3. Originality: novelty of ideas (semantic similarity - lower is better, weight 0.30)
              // Calculate average semantic similarity between nodes (lower = more original)
              let totalSimilarity = 0;
              let similarityCount = 0;
              for (let i = 0; i < actorNodes.length; i++) {
                for (let j = i + 1; j < actorNodes.length; j++) {
                  const text1 = actorNodes[i].text || actorNodes[i].title || '';
                  const text2 = actorNodes[j].text || actorNodes[j].title || '';
                  if (text1 && text2) {
                    const similarity = calculateTextSimilarity(text1, text2);
                    totalSimilarity += similarity;
                    similarityCount++;
                  }
                }
              }
              const avgSimilarity = similarityCount > 0 ? totalSimilarity / similarityCount : 0;
              // Lower similarity = higher originality (invert: 1 - similarity)
              const originality = (1 - avgSimilarity) * 100;

              // 4. Elaboration: depth and linkage (density + length, weight 0.20)
              // Depth: average node level
              const avgDepth = actorNodes.reduce((sum, n) => sum + (n.level || 0), 0) / actorNodes.length;
              // Length: average text length
              const avgLength = actorNodes.reduce((sum, n) => {
                const text = n.text || n.title || '';
                return sum + text.length;
              }, 0) / actorNodes.length;
              // Linkage: nodes with parent connections
              const linkedNodes = actorNodes.filter(n => n.parentId || (n.parentIds && n.parentIds.length > 0)).length;
              const linkageRatio = actorNodes.length > 0 ? linkedNodes / actorNodes.length : 0;

              // Normalize: depth (0-5), length (0-200 chars), linkage (0-1)
              const depthScore = Math.min((avgDepth / 5) * 100, 100);
              const lengthScore = Math.min((avgLength / 200) * 100, 100);
              const linkageScore = linkageRatio * 100;
              const elaboration = (depthScore * 0.3 + lengthScore * 0.4 + linkageScore * 0.3);

              return {
                fluency: Math.max(0, Math.min(100, fluency)),
                flexibility: Math.max(0, Math.min(100, flexibility)),
                originality: Math.max(0, Math.min(100, originality)),
                elaboration: Math.max(0, Math.min(100, elaboration))
              };
            };

            // Calculate Dependency: AI nodes √∑ total nodes
            const totalNodes = nodes.length;
            const aiNodes = nodes.filter(n => {
              // Check if node was created by AI (not edited by human)
              const createEvent = eventHistory.find(e => e.event_type === 'Create Node' && e.node_id === n.id.toString());
              return createEvent?.actor === 'AI' || (!n.edited && totalNodes > 0);
            }).length;
            const dependency = totalNodes > 0 ? (aiNodes / totalNodes) * 100 : 0;

            // Calculate TTCT scores for AI and Human
            const aiScores = calculateTTCTScores('AI');
            const humanScores = calculateTTCTScores('HUMAN');

            // Calculate final Creativity Index: CI' = 0.25F + 0.25X + 0.30O + 0.20E ‚Äì 0.20D
            // For AI and Human separately
            const aiCI = 0.25 * (aiScores.fluency / 100) +
              0.25 * (aiScores.flexibility / 100) +
              0.30 * (aiScores.originality / 100) +
              0.20 * (aiScores.elaboration / 100) -
              0.20 * (dependency / 100);

            const humanCI = 0.25 * (humanScores.fluency / 100) +
              0.25 * (humanScores.flexibility / 100) +
              0.30 * (humanScores.originality / 100) +
              0.20 * (humanScores.elaboration / 100) -
              0.20 * (dependency / 100);

            // Determine strengths
            const humanStrengths = [];
            const aiStrengths = [];
            if (humanScores.flexibility > aiScores.flexibility) humanStrengths.push('Flexibility');
            if (humanScores.originality > aiScores.originality) humanStrengths.push('Originality');
            if (aiScores.fluency > humanScores.fluency) aiStrengths.push('Fluency');
            if (aiScores.elaboration > humanScores.elaboration) aiStrengths.push('Elaboration');

            return (
              <>
                {/* TTCT Creativity Dimensions and Side-by-Side Comparison */}
                <div className="grid grid-cols-2 gap-6 mb-6">
                  {/* Left: TTCT Creativity Dimensions - Radar Chart */}
                  <div className="bg-white rounded-lg p-6 shadow-md border border-gray-200">
                    <h3 className="text-lg font-bold text-gray-800 mb-4">TTCT Creativity Dimensions</h3>
                    <div className="flex items-center justify-center my-8">
                      <svg width="400" height="400" viewBox="0 0 400 400" style={{ overflow: 'visible' }}>
                        {/* Grid circles */}
                        {[25, 50, 75, 100].map((radius) => (
                          <circle
                            key={radius}
                            cx="200"
                            cy="200"
                            r={radius * 1.5}
                            fill="none"
                            stroke="#e5e7eb"
                            strokeWidth="1"
                            strokeDasharray="2,2"
                          />
                        ))}

                        {/* Axes - 4 axes (90 degrees apart) */}
                        {[
                          { label: 'Fluency', angle: -90 },
                          { label: 'Flexibility', angle: 0 },
                          { label: 'Originality', angle: 90 },
                          { label: 'Elaboration', angle: 180 }
                        ].map((axis) => {
                          const angle = (axis.angle * Math.PI) / 180;
                          const centerX = 200;
                          const centerY = 200;
                          const axisLength = 150;
                          const x = centerX + axisLength * Math.cos(angle);
                          const y = centerY + axisLength * Math.sin(angle);

                          const labelDistance = 30;
                          const labelX = centerX + (axisLength + labelDistance) * Math.cos(angle);
                          const labelY = centerY + (axisLength + labelDistance) * Math.sin(angle);

                          return (
                            <g key={axis.label}>
                              <line
                                x1={centerX}
                                y1={centerY}
                                x2={x}
                                y2={y}
                                stroke="#d1d5db"
                                strokeWidth="1"
                              />
                              <g>
                                <rect
                                  x={labelX - (axis.label.length * 3.5)}
                                  y={labelY - 8}
                                  width={axis.label.length * 7}
                                  height={16}
                                  fill="white"
                                  fillOpacity="0.9"
                                  stroke="none"
                                  rx="2"
                                />
                                <text
                                  x={labelX}
                                  y={labelY + 4}
                                  fontSize="11"
                                  fill="#374151"
                                  textAnchor="middle"
                                  fontWeight="600"
                                  style={{ pointerEvents: 'none' }}
                                >
                                  {axis.label}
                                </text>
                              </g>
                            </g>
                          );
                        })}

                        {/* AI Polygon (pink) */}
                        <polygon
                          points={[
                            `${200 + (aiScores.fluency / 100) * 150 * Math.cos(-90 * Math.PI / 180)},${200 + (aiScores.fluency / 100) * 150 * Math.sin(-90 * Math.PI / 180)}`,
                            `${200 + (aiScores.flexibility / 100) * 150 * Math.cos(0 * Math.PI / 180)},${200 + (aiScores.flexibility / 100) * 150 * Math.sin(0 * Math.PI / 180)}`,
                            `${200 + (aiScores.originality / 100) * 150 * Math.cos(90 * Math.PI / 180)},${200 + (aiScores.originality / 100) * 150 * Math.sin(90 * Math.PI / 180)}`,
                            `${200 + (aiScores.elaboration / 100) * 150 * Math.cos(180 * Math.PI / 180)},${200 + (aiScores.elaboration / 100) * 150 * Math.sin(180 * Math.PI / 180)}`
                          ].join(' ')}
                          fill="#ec4899"
                          fillOpacity="0.3"
                          stroke="#ec4899"
                          strokeWidth="2"
                        />

                        {/* Human Polygon (purple) */}
                        {eventHistory.some(e => e.actor === 'HUMAN') && (
                          <polygon
                            points={[
                              `${200 + (humanScores.fluency / 100) * 150 * Math.cos(-90 * Math.PI / 180)},${200 + (humanScores.fluency / 100) * 150 * Math.sin(-90 * Math.PI / 180)}`,
                              `${200 + (humanScores.flexibility / 100) * 150 * Math.cos(0 * Math.PI / 180)},${200 + (humanScores.flexibility / 100) * 150 * Math.sin(0 * Math.PI / 180)}`,
                              `${200 + (humanScores.originality / 100) * 150 * Math.cos(90 * Math.PI / 180)},${200 + (humanScores.originality / 100) * 150 * Math.sin(90 * Math.PI / 180)}`,
                              `${200 + (humanScores.elaboration / 100) * 150 * Math.cos(180 * Math.PI / 180)},${200 + (humanScores.elaboration / 100) * 150 * Math.sin(180 * Math.PI / 180)}`
                            ].join(' ')}
                            fill="#8b5cf6"
                            fillOpacity="0.3"
                            stroke="#8b5cf6"
                            strokeWidth="2"
                          />
                        )}
                      </svg>
                    </div>
                    <div className="flex items-center justify-center gap-4 mt-6">
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 rounded bg-pink-500"></div>
                        <span className="text-sm text-gray-700">AI</span>
                      </div>
                      {eventHistory.some(e => e.actor === 'HUMAN') && (
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-4 rounded bg-purple-500"></div>
                          <span className="text-sm text-gray-700">Human</span>
                        </div>
                      )}
                    </div>

                    {/* Insight */}
                    <div className="mt-6 bg-purple-50 rounded-lg p-4">
                      <p className="text-sm text-gray-700">
                        {humanStrengths.length > 0 && aiStrengths.length > 0
                          ? `Your ${humanStrengths.join(' & ')} scores are higher than AI contributions, indicating strong creative independence.`
                          : humanStrengths.length > 0
                            ? `Your ${humanStrengths.join(' & ')} scores are higher than AI contributions.`
                            : 'Your creative process shows a balanced collaboration between human insight and AI assistance.'}
                      </p>
                    </div>
                  </div>

                  {/* Right: Side-by-Side Comparison - Bar Chart */}
                  <div className="bg-white rounded-lg p-6 shadow-md border border-gray-200">
                    <h3 className="text-lg font-bold text-gray-800 mb-4">Side-by-Side Comparison</h3>
                    <div className="space-y-6 mt-8">
                      {['Fluency', 'Flexibility', 'Originality', 'Elaboration'].map((dimension) => {
                        const aiScore = aiScores[dimension.toLowerCase() as keyof typeof aiScores];
                        const humanScore = humanScores[dimension.toLowerCase() as keyof typeof humanScores];
                        return (
                          <div key={dimension}>
                            <div className="flex justify-between mb-2">
                              <span className="text-sm font-medium text-gray-700">{dimension}</span>
                            </div>
                            <div className="space-y-2">
                              <div className="flex items-center gap-3">
                                <span className="text-xs text-gray-600 w-12">AI</span>
                                <div className="flex-1 bg-gray-200 rounded-full h-4 relative">
                                  <div
                                    className="bg-pink-500 h-4 rounded-full"
                                    style={{ width: `${aiScore}%` }}
                                  ></div>
                                  <span className="absolute right-2 top-0 text-xs text-gray-700 leading-4">{Math.round(aiScore)}</span>
                                </div>
                              </div>
                              {eventHistory.some(e => e.actor === 'HUMAN') && (
                                <div className="flex items-center gap-3">
                                  <span className="text-xs text-gray-600 w-12">Human</span>
                                  <div className="flex-1 bg-gray-200 rounded-full h-4 relative">
                                    <div
                                      className="bg-purple-500 h-4 rounded-full"
                                      style={{ width: `${humanScore}%` }}
                                    ></div>
                                    <span className="absolute right-2 top-0 text-xs text-gray-700 leading-4">{Math.round(humanScore)}</span>
                                  </div>
                                </div>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>

                    <div className="flex items-center justify-center gap-4 mt-6">
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 rounded bg-pink-500"></div>
                        <span className="text-sm text-gray-700">AI</span>
                      </div>
                      {eventHistory.some(e => e.actor === 'HUMAN') && (
                        <div className="flex items-center gap-2">
                          <div className="w-4 h-4 rounded bg-purple-500"></div>
                          <span className="text-sm text-gray-700">Human</span>
                        </div>
                      )}
                    </div>

                    {/* Strengths */}
                    <div className="grid grid-cols-2 gap-4 mt-6">
                      {humanStrengths.length > 0 && (
                        <div className="bg-purple-50 rounded-lg p-4">
                          <div className="flex items-center gap-2 mb-2">
                            <svg className="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                            </svg>
                            <span className="text-sm font-semibold text-gray-800">Your Strength</span>
                          </div>
                          <p className="text-xs text-gray-700">{humanStrengths.join(' & ')}</p>
                        </div>
                      )}
                      {aiStrengths.length > 0 && (
                        <div className="bg-pink-50 rounded-lg p-4">
                          <div className="flex items-center gap-2 mb-2">
                            <svg className="w-5 h-5 text-pink-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                            </svg>
                            <span className="text-sm font-semibold text-gray-800">AI Strength</span>
                          </div>
                          <p className="text-xs text-gray-700">{aiStrengths.join(' & ')}</p>
                        </div>
                      )}
                    </div>
                  </div>
                </div>

                {/* Understanding TTCT Dimensions */}
                <div className="bg-white rounded-lg p-6 shadow-md border border-gray-200">
                  <h3 className="text-lg font-bold text-gray-800 mb-4">Understanding TTCT Dimensions</h3>
                  <div className="grid grid-cols-2 gap-6">
                    <div>
                      <h4 className="font-semibold text-gray-800 mb-2">Fluency</h4>
                      <p className="text-sm text-gray-600">The ability to generate a large number of ideas quickly. Measures idea quantity and brainstorming productivity.</p>
                    </div>
                    <div>
                      <h4 className="font-semibold text-gray-800 mb-2">Flexibility</h4>
                      <p className="text-sm text-gray-600">The ability to approach problems from different perspectives and switch between categories of thinking.</p>
                    </div>
                    <div>
                      <h4 className="font-semibold text-gray-800 mb-2">Originality</h4>
                      <p className="text-sm text-gray-600">The uniqueness and novelty of ideas. Measures how different your concepts are from common responses.</p>
                    </div>
                    <div>
                      <h4 className="font-semibold text-gray-800 mb-2">Elaboration</h4>
                      <p className="text-sm text-gray-600">The ability to develop and add detail to ideas. Measures depth and completeness of concepts.</p>
                    </div>
                  </div>
                </div>
              </>
            );
          })()}
        </div>
      </div >
    );
  }

  // Landing Page
  if (showLandingPage) {
    return (
      <div className="w-full h-screen bg-gradient-to-br from-pink-50 via-purple-50 to-blue-50 flex flex-col items-center justify-center p-8">
        {/* Logo and Tagline */}
        <div className="text-center mb-12">
          {/* Logo Image */}
          <div className="mb-6 flex justify-center">
            <img
              src="/logo.svg"
              alt="Logo"
              className="h-24 w-auto object-contain"
              onError={(e) => {
                // If logo doesn't exist, hide the image element
                e.currentTarget.style.display = 'none';
              }}
            />
          </div>
          <p className="text-lg text-gray-700 mt-4 max-w-2xl">
            Transform your ideas into structured insights with AI-powered exploration.
          </p>
        </div>

        {/* Idea Input Section */}
        <div className="bg-white rounded-xl shadow-2xl p-8 w-full max-w-3xl mb-12">
          <h2 className="text-2xl font-semibold text-gray-800 mb-4">Type down your idea</h2>
          <textarea
            value={landingInputValue}
            onChange={(e) => setLandingInputValue(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !loading && landingInputValue.trim()) {
                if (e.shiftKey) {
                  // Shift+Enter: new line
                  return;
                }
                e.preventDefault();
                handleStartExploration();
              }
            }}
            placeholder="Enter your creative concept, problem to solve, or topic to explore..."
            className="w-full px-4 py-4 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-purple-500 resize-none mb-4 min-h-[120px] text-base"
            disabled={loading}
          />
          <div className="flex items-center justify-between">
            <p className="text-sm text-gray-500">Press Enter to start</p>
            <button
              onClick={handleStartExploration}
              disabled={loading || !landingInputValue.trim()}
              className="flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg hover:from-purple-700 hover:to-blue-700 disabled:from-gray-300 disabled:to-gray-300 disabled:cursor-not-allowed font-semibold text-lg transition-all shadow-lg"
            >
              {loading ? 'Starting...' : 'Start Exploration'}
              <ArrowRight size={20} />
            </button>
          </div>
        </div>

        {/* Features Section */}
        <div className="text-center">
          <h3 className="text-xl font-semibold text-gray-800 mb-6">Features</h3>
          <div className="flex gap-12 justify-center">
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-purple-500"></div>
              <span className="text-gray-700 font-medium">Semantic Graph</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-blue-500"></div>
              <span className="text-gray-700 font-medium">Reflection Panel</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-green-500"></div>
              <span className="text-gray-700 font-medium">Creativity Report</span>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col">
      <div className="flex-1 flex overflow-hidden relative">
        {/* Top Menu Bar - Only in Exploration Mode, Canvas Centered */}
        {mode === 'exploration' && nodes.length > 0 && (
          <div className={`absolute top-6 z-50 ${isReflectionSidebarOpen ? 'left-[calc(50%-200px)]' : 'left-1/2'} transform -translate-x-1/2`}>
            <div className="bg-white rounded-lg shadow-lg border border-purple-200 px-2 py-2 flex items-center gap-1">
              {/* Home Button */}
              <button
                onClick={handleHome}
                className="flex items-center gap-2 px-4 py-2 rounded-lg hover:bg-purple-50 transition-colors text-gray-700 font-medium"
                title="Return to home"
              >
                <Home size={18} />
                <span>Home</span>
              </button>

              {/* Divider */}
              <div className="w-px h-8 bg-gray-300"></div>

              {/* Structure Mode Button - Go to existing structure if available */}
              <button
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  // Only allow navigation if hierarchyAnalysis exists
                  if (!hierarchyAnalysis) {
                    return; // Do nothing if no structure exists
                  }
                  // If hierarchyAnalysis exists, just switch to structure mode
                  // Position recalculation will be handled by useEffect
                  setMode('structure');
                }}
                disabled={!hierarchyAnalysis}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-all text-gray-700 font-medium ${hierarchyAnalysis
                  ? 'bg-purple-100 hover:bg-purple-200 text-purple-700 shadow-md hover:scale-105 active:scale-95 cursor-pointer'
                  : 'bg-gray-100 text-gray-400 cursor-not-allowed opacity-50'
                  }`}
                title={hierarchyAnalysis ? 'Go to Structure Mode' : 'No structure available. Generate structure first using "Generate Structure" button.'}
              >
                <LayoutGrid size={18} />
                <span>Structure Mode</span>
              </button>

              {/* Divider */}
              <div className="w-px h-8 bg-gray-300"></div>

              {/* Generate Structure Button */}
              <button
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  // Add click animation
                  e.currentTarget.style.transform = 'scale(0.95)';
                  setTimeout(() => {
                    e.currentTarget.style.transform = '';
                  }, 150);
                  analyzeHierarchy();
                }}
                disabled={analyzingStructure || selectedForStructure.size < 2}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-all text-gray-700 font-medium ${selectedForStructure.size >= 2 && !analyzingStructure
                  ? 'bg-purple-100 hover:bg-purple-200 text-purple-700 shadow-md animate-pulse hover:scale-105 active:scale-95'
                  : analyzingStructure
                    ? 'bg-purple-200 text-purple-800 shadow-lg cursor-wait'
                    : 'hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  }`}
                title={analyzingStructure ? 'Analyzing structure...' : selectedForStructure.size >= 2 ? `Generate Structure (${selectedForStructure.size} selected)` : 'Select at least 2 nodes to generate structure'}
              >
                {analyzingStructure ? (
                  <>
                    <div className="w-4 h-4 border-2 border-purple-600 border-t-transparent rounded-full animate-spin"></div>
                    <span>Analyzing...</span>
                  </>
                ) : (
                  <>
                    <LayoutGrid size={18} />
                    <span>Generate Structure</span>
                    {selectedForStructure.size >= 2 && (
                      <span className="ml-1 px-2 py-0.5 bg-purple-600 text-white text-xs rounded-full">
                        {selectedForStructure.size}
                      </span>
                    )}
                  </>
                )}
              </button>

              {/* Divider */}
              <div className="w-px h-8 bg-gray-300"></div>

              {/* Expand with AI Button */}
              <button
                onClick={handleExpandAll}
                disabled={loading}
                className="flex items-center gap-2 px-4 py-2 rounded-lg hover:bg-orange-50 transition-colors text-gray-700 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                title="Expand all leaf nodes with AI"
              >
                <Sparkles size={18} className="text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-orange-500" />
                <span>Expand with AI</span>
              </button>
            </div>
          </div>
        )}
        <div
          className="flex-1 overflow-auto relative"
          onMouseDown={handleCanvasMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
          style={{
            cursor: isSpacePressed ? (isPanning ? 'grabbing' : 'grab') : 'default'
          }}
        >
          <svg className="absolute top-0 left-0 w-full h-full pointer-events-none">
            <defs>
              <linearGradient id="multiSelectGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stopColor="#a855f7" stopOpacity="0.8" />
                <stop offset="50%" stopColor="#ec4899" stopOpacity="0.8" />
                <stop offset="100%" stopColor="#f59e0b" stopOpacity="0.8" />
              </linearGradient>
            </defs>
            {renderConnections()}
          </svg>

          {nodes.map(node => {
            const pos = getNodePosition(node);
            const isEditing = editingNode === node.id;
            const isSelected = selectedNode === node.id;
            const isFocused = focusedNode === node.id;

            // Determine node creation type: Human, AI, or Co-creation
            const getNodeCreationType = (node) => {
              // Check if node was created by AI (check both string and number ID formats)
              const aiCreateEvent = eventHistory.find(e =>
                e.event_type === 'Create Node' &&
                e.actor === 'AI' &&
                (e.node_id === node.id.toString() || e.node_id === node.id ||
                  (e.node_ids_involved && e.node_ids_involved.includes(node.id.toString())) ||
                  (e.node_ids_involved && e.node_ids_involved.includes(node.id)))
              );

              // Check if node was created by Human
              const humanCreateEvent = eventHistory.find(e =>
                e.event_type === 'Create Node' &&
                e.actor === 'HUMAN' &&
                (e.node_id === node.id.toString() || e.node_id === node.id)
              );

              // Check if node was edited by Human (check both string and number ID formats)
              const humanEditEvent = eventHistory.find(e =>
                e.event_type === 'Edit Node' &&
                e.actor === 'HUMAN' &&
                (e.node_id === node.id.toString() || e.node_id === node.id)
              );

              // Co-creation: AI created and Human edited
              // Priority: Check edited flag first, then event history
              if (aiCreateEvent && (node.edited || humanEditEvent)) {
                return 'co-creation';
              }

              // Human: Human created (or manually created without AI)
              if (humanCreateEvent || (!aiCreateEvent && node.edited)) {
                return 'human';
              }

              // AI: AI created and not edited
              if (aiCreateEvent && !humanEditEvent && !node.edited) {
                return 'ai';
              }

              // Default: assume AI if no clear indication (most nodes are AI-generated)
              return 'ai';
            };

            const nodeCreationType = getNodeCreationType(node);
            const isSelectedForStructure = selectedForStructure.has(node.id);
            const isDragging = draggingNode === node.id;
            const isNodeHovered = hoveredNodeId === node.id;

            const nodeSize = node.type === 'topic' ? 140 : node.type === 'main' ? 120 : node.type === 'sub' ? 100 : node.type === 'insight' ? 80 : 80;
            const buttonRadius = (nodeSize / 2) + 10; // Î≤ÑÌäºÎì§Ïù¥ ÎÖ∏Îìú Ï£ºÎ≥ÄÏóê Î∞∞ÏπòÎê† Î∞òÍ≤Ω (Îçî Í∞ÄÍπùÍ≤å)
            const hoverAreaSize = nodeSize + (buttonRadius * 2) + 20; // Hover ÏòÅÏó≠ ÌôïÏû•
            const clickAreaSize = nodeSize + 10; // ÌÅ¥Î¶≠ ÏòÅÏó≠ÏùÑ ÎÖ∏Îìú ÌÅ¨Í∏∞Î≥¥Îã§ ÏïΩÍ∞Ñ ÌÅ¨Í≤å (Í≤πÏπòÎäî ÎÖ∏Îìú Íµ¨Î∂Ñ)

            return (
              <div
                key={node.id}
                ref={el => nodeRefs.current[node.id] = el}
                onMouseEnter={() => setHoveredNodeId(node.id)}
                onMouseLeave={() => setHoveredNodeId(null)}
                className="absolute"
                style={{
                  left: `${pos.x - (hoverAreaSize - nodeSize) / 2}px`,
                  top: `${pos.y - (hoverAreaSize - nodeSize) / 2}px`,
                  width: `${hoverAreaSize}px`,
                  height: `${hoverAreaSize}px`,
                  pointerEvents: isSpacePressed ? 'none' : 'auto'
                }}
              >
                {/* ÎÖ∏Îìú ÏòÅÏó≠ - ÎìúÎûòÍ∑∏ Í∞ÄÎä• */}
                <div
                  onMouseDown={(e) => {
                    // Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú ÎìúÎûòÍ∑∏ Î∞©ÏßÄ
                    const target = e.target as HTMLElement;
                    if (!target.closest('button') && target.tagName !== 'BUTTON') {
                      handleMouseDown(e, node);
                    }
                  }}
                  onClick={(e) => {
                    // ÎÖ∏Îìú Ï†ÑÏ≤¥ ÏòÅÏó≠ ÌÅ¥Î¶≠ Ï≤òÎ¶¨ (Î≤ÑÌäº Ï†úÏô∏, ÎìúÎûòÍ∑∏Í∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå)
                    const target = e.target as HTMLElement;
                    const isDrag = draggingNode === node.id && (
                      Math.abs(e.clientX - mouseDownPos.x) > 5 ||
                      Math.abs(e.clientY - mouseDownPos.y) > 5
                    );

                    if (!target.closest('button') && target.tagName !== 'BUTTON' && !isSpacePressed && !isDrag) {
                      handleNodeClick(node, e);
                    }
                  }}
                  className="absolute"
                  style={{
                    left: '50%',
                    top: '50%',
                    transform: 'translate(-50%, -50%)',
                    width: `${clickAreaSize}px`,
                    height: `${clickAreaSize}px`,
                    cursor: isSpacePressed ? (isPanning ? 'grabbing' : 'grab') : (isDragging ? 'grabbing' : 'grab'),
                    pointerEvents: 'auto',
                    zIndex: isSelected || hoveredNodeId === node.id ? 20 : 1
                  }}
                >
                  {isEditing ? (
                    <div className="bg-white p-3 rounded-lg shadow-lg border-2 border-blue-500">
                      <textarea
                        value={editValue}
                        onChange={(e) => setEditValue(e.target.value)}
                        className="w-full p-2 border rounded text-sm resize-none"
                        rows={3}
                        autoFocus
                      />
                      <div className="flex gap-2 mt-2">
                        <button
                          onClick={handleEditSave}
                          className="flex-1 px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600"
                        >
                          Save
                        </button>
                        <button
                          onClick={() => setEditingNode(null)}
                          className="flex-1 px-2 py-1 bg-gray-400 text-white rounded text-xs hover:bg-gray-500"
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  ) : (
                    <>
                      <div
                        className={`rounded-full shadow-md cursor-pointer hover:shadow-xl transition-all relative flex flex-col items-center justify-center ${isSelected ? 'scale-105 ring-2 ring-blue-400' : isFocused ? 'scale-110 shadow-2xl' : ''} ${node.isAnimating ? 'node-appear' : ''}`}
                        style={{
                          transition: node.isAnimating ? 'none' : 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
                          width: '100%',
                          height: '100%',
                          padding: isSelectedForStructure && selectedForStructure.size > 1 ? '3px' : '0px',
                          background: isSelectedForStructure && selectedForStructure.size > 1
                            ? 'linear-gradient(135deg, #a855f7 0%, #ec4899 50%, #f59e0b 100%)'
                            : 'transparent',
                          animation: isSelectedForStructure && selectedForStructure.size > 1 ? 'gradientSpread 0.6s ease-out' : undefined
                        }}
                      >
                        {/* Gradient border wrapper for all node types */}
                        {(() => {
                          // Determine gradient colors based on node creation type
                          let borderGradient = '';
                          let backgroundGradient = '';

                          if (nodeCreationType === 'co-creation') {
                            borderGradient = 'linear-gradient(to right, #f0abfc 0%, #fda4af 100%)';
                            backgroundGradient = 'linear-gradient(to right, #f0abfc 0%, #fda4af 100%)'; // Same gradient as border for co-creation
                          } else if (nodeCreationType === 'human') {
                            borderGradient = 'linear-gradient(to right, #c084fc 0%, #a855f7 100%)'; // Light purple to purple gradient
                            backgroundGradient = 'radial-gradient(circle, #ffffff 0%, #e9d5ff 100%)';
                          } else if (nodeCreationType === 'ai') {
                            borderGradient = 'linear-gradient(to right, #fb923c 0%, #f97316 100%)'; // Light orange to orange gradient
                            backgroundGradient = 'radial-gradient(circle, #ffffff 0%, #fed7aa 100%)';
                          } else {
                            // Default node types (topic, main, sub, insight, opportunity)
                            const defaultColors = {
                              topic: { border: 'linear-gradient(to right, #d8b4fe 0%, #a855f7 100%)', bg: '#f3e8ff' },
                              main: { border: 'linear-gradient(to right, #93c5fd 0%, #3b82f6 100%)', bg: '#eff6ff' },
                              sub: { border: 'linear-gradient(to right, #86efac 0%, #10b981 100%)', bg: '#f0fdf4' },
                              insight: { border: 'linear-gradient(to right, #fde047 0%, #eab308 100%)', bg: '#fefce8' },
                              opportunity: { border: 'linear-gradient(to right, #e9d5ff 0%, #a855f7 100%)', bg: '#faf5ff' }
                            };
                            const nodeColor = defaultColors[node.type] || { border: 'linear-gradient(to right, #e5e7eb 0%, #9ca3af 100%)', bg: '#ffffff' };
                            borderGradient = nodeColor.border;
                            backgroundGradient = nodeColor.bg;
                          }

                          return (
                            <div
                              className="rounded-full w-full h-full relative"
                              style={{
                                background: borderGradient,
                                padding: '2px' // Consistent border thickness for all nodes
                              }}
                            >
                              <div
                                className="rounded-full w-full h-full flex flex-col items-center justify-center relative transition-all"
                                style={{
                                  transition: 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
                                  background: backgroundGradient,
                                  padding: node.type === 'topic' ? '14px' : node.type === 'main' ? '12px' : node.type === 'sub' ? '10px' : '8px',
                                  boxShadow: isSelectedForStructure && selectedForStructure.size > 1
                                    ? '0 0 15px rgba(236, 72, 153, 0.4), 0 0 25px rgba(245, 158, 11, 0.3)'
                                    : undefined
                                }}
                              >
                                {node.category && (
                                  <span className="absolute -top-2 left-1/2 transform -translate-x-1/2 px-2 py-0.5 rounded-full text-xs font-semibold text-gray-600 bg-white shadow-sm border border-gray-200 whitespace-nowrap">
                                    {node.category}
                                  </span>
                                )}
                                <div
                                  className="cursor-pointer w-full h-full flex flex-col items-center justify-center text-center px-2 py-1"
                                  style={{
                                    maxWidth: '100%',
                                    overflow: isSelected ? 'auto' : 'hidden',
                                    wordBreak: 'break-word'
                                  }}
                                >
                                  {/* Title - ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùÄ ÎÖ∏ÎìúÎäî ÎßêÏ§ÑÏûÑÌëú, ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎäî Ï†ÑÏ≤¥ title ÌëúÏãú */}
                                  <p
                                    className={`break-words text-gray-700 leading-tight font-semibold ${node.type === 'topic' ? 'text-sm' : node.type === 'main' ? 'text-xs' : 'text-xs'}`}
                                    style={{
                                      maxWidth: '100%',
                                      overflow: isSelected ? 'visible' : 'hidden',
                                      lineHeight: '1.3',
                                      display: isSelected ? 'block' : '-webkit-box',
                                      WebkitLineClamp: isSelected ? undefined : 2,
                                      WebkitBoxOrient: isSelected ? 'initial' : 'vertical',
                                      wordBreak: 'break-word'
                                    }}
                                    title={!isSelected ? (node.title || node.text) : undefined}
                                  >
                                    {node.title || node.text}
                                  </p>
                                </div>
                              </div>
                            </div>
                          );
                        })()}
                      </div>
                    </>
                  )}
                </div>

                {/* Î≤ÑÌäº ÏòÅÏó≠ - hover ÏÉÅÌÉú Ïú†ÏßÄ */}
                {isNodeHovered && !isEditing && (
                  <>
                    {/* Top-right: Generate (Zap) - Í∞úÎ≥Ñ ÎÖ∏Îìú generate */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        handleGenerate(node);
                      }}
                      onMouseDown={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                      }}
                      onMouseEnter={() => setHoveredNodeId(node.id)}
                      onMouseLeave={() => setHoveredNodeId(node.id)}
                      className="absolute w-8 h-8 bg-white rounded-full shadow-lg border-2 border-green-300 flex items-center justify-center hover:bg-green-50 transition-colors z-20"
                      style={{
                        left: '50%',
                        top: '50%',
                        transform: `translate(calc(-50% + ${buttonRadius * Math.cos(Math.PI * 0.25)}px), calc(-50% - ${buttonRadius * Math.sin(Math.PI * 0.25)}px))`,
                        pointerEvents: 'auto'
                      }}
                      title={node.type === 'topic' ? 'Topic Node' :
                        node.type === 'main' ? 'Expand to Sub-nodes' :
                          node.type === 'sub' ? 'Generate Insights' :
                            node.type === 'insight' ? 'Generate Opportunities' :
                              'Generate'}
                      disabled={loading}
                    >
                      <Zap size={14} className="text-green-600" />
                    </button>

                    {/* Top-right next to Generate: Multi-generate (Ïó¨Îü¨ ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎ°úÎ∂ÄÌÑ∞ generate) */}
                    {selectedForStructure.size > 1 && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          e.preventDefault();
                          const selectedNodesList = nodes.filter(n => selectedForStructure.has(n.id));
                          generateMultiSelection(selectedNodesList);
                        }}
                        onMouseDown={(e) => {
                          e.stopPropagation();
                          e.preventDefault();
                        }}
                        onMouseEnter={() => setHoveredNodeId(node.id)}
                        onMouseLeave={() => setHoveredNodeId(node.id)}
                        className="absolute w-8 h-8 bg-white rounded-full shadow-lg border-2 border-purple-300 flex items-center justify-center hover:bg-purple-50 transition-colors z-20"
                        style={{
                          left: '50%',
                          top: '50%',
                          transform: `translate(calc(-50% + ${buttonRadius * Math.cos(Math.PI * 0.15)}px), calc(-50% - ${buttonRadius * Math.sin(Math.PI * 0.15)}px))`,
                          pointerEvents: 'auto'
                        }}
                        title={`Generate from ${selectedForStructure.size} selected nodes`}
                        disabled={loading}
                      >
                        <Sparkles size={14} className="text-purple-600" />
                      </button>
                    )}

                    {/* Middle-right: Edit */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        handleEdit(node);
                      }}
                      onMouseDown={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                      }}
                      onMouseEnter={() => setHoveredNodeId(node.id)}
                      onMouseLeave={() => setHoveredNodeId(node.id)}
                      className="absolute w-8 h-8 bg-white rounded-full shadow-lg border-2 border-blue-300 flex items-center justify-center hover:bg-blue-50 transition-colors z-20"
                      style={{
                        left: '50%',
                        top: '50%',
                        transform: `translate(calc(-50% + ${buttonRadius}px), calc(-50% + 0px))`,
                        pointerEvents: 'auto'
                      }}
                      title="Edit"
                    >
                      <Edit2 size={14} className="text-blue-600" />
                    </button>

                    {/* Bottom-right: Delete */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        handleDelete(node.id);
                      }}
                      onMouseDown={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                      }}
                      onMouseEnter={() => setHoveredNodeId(node.id)}
                      onMouseLeave={() => setHoveredNodeId(node.id)}
                      className="absolute w-8 h-8 bg-white rounded-full shadow-lg border-2 border-red-300 flex items-center justify-center hover:bg-red-50 transition-colors z-20"
                      style={{
                        left: '50%',
                        top: '50%',
                        transform: `translate(calc(-50% + ${buttonRadius * Math.cos(Math.PI * -0.25)}px), calc(-50% - ${buttonRadius * Math.sin(Math.PI * -0.25)}px))`,
                        pointerEvents: 'auto'
                      }}
                      title="Delete"
                    >
                      <Trash2 size={14} className="text-red-600" />
                    </button>

                    {/* Bottom-left: Add */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        handleAddNodeClick(node);
                      }}
                      onMouseDown={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                      }}
                      onMouseEnter={() => setHoveredNodeId(node.id)}
                      onMouseLeave={() => setHoveredNodeId(node.id)}
                      className="absolute w-8 h-8 bg-white rounded-full shadow-lg border-2 border-gray-300 flex items-center justify-center hover:bg-gray-50 transition-colors z-20"
                      style={{
                        left: '50%',
                        top: '50%',
                        transform: `translate(calc(-50% - ${buttonRadius * Math.cos(Math.PI * 0.25)}px), calc(-50% + ${buttonRadius * Math.sin(Math.PI * 0.25)}px))`,
                        pointerEvents: 'auto'
                      }}
                      title="Add Node"
                    >
                      <Plus size={14} className="text-gray-600" />
                    </button>
                  </>
                )}
              </div>
            );
          })}

          {loading && (
            <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-[9999] flex items-center justify-center">
              <div className="bg-white rounded-xl shadow-2xl px-8 py-6 flex flex-col items-center gap-4 min-w-[200px]">
                <div className="w-12 h-12 border-4 border-purple-200 border-t-purple-600 rounded-full loading-spinner"></div>
                <p className="text-gray-700 font-semibold text-lg">Generating ideas...</p>
                <p className="text-gray-500 text-sm">Please wait</p>
              </div>
            </div>
          )}

          {/* Add Node Modal */}
          {addNodeModal && (
            <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-[9999] flex items-center justify-center" onClick={handleAddNodeCancel}>
              <div className="bg-white rounded-xl shadow-2xl p-6 min-w-[400px] max-w-[500px]" onClick={(e) => e.stopPropagation()}>
                <h3 className="text-lg font-bold text-gray-800 mb-4">Add New Node</h3>
                <p className="text-sm text-gray-600 mb-4">
                  Enter the text for the new node that will be connected to "{nodes.find(n => n.id === addNodeModal)?.text || ''}"
                </p>
                <textarea
                  value={addNodeText}
                  onChange={(e) => setAddNodeText(e.target.value)}
                  placeholder="Enter node text..."
                  className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent resize-none"
                  rows={4}
                  autoFocus
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                      handleAddNodeSubmit();
                    } else if (e.key === 'Escape') {
                      handleAddNodeCancel();
                    }
                  }}
                />
                <div className="flex gap-3 mt-6 justify-end">
                  <button
                    onClick={handleAddNodeCancel}
                    className="px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleAddNodeSubmit}
                    disabled={!addNodeText.trim()}
                    className="px-4 py-2 text-white bg-purple-600 rounded-lg hover:bg-purple-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
                  >
                    Add Node
                  </button>
                </div>
              </div>
            </div>
          )}


          {/* Node Detail Card - shown when a node is selected in exploration mode */}
          {mode === 'exploration' && selectedNode && (() => {
            const selectedNodeData = nodes.find(n => n.id === selectedNode);
            if (!selectedNodeData) return null;

            // Determine node type label
            const getNodeTypeLabel = (node) => {
              if (node.category) return node.category;
              if (node.type === 'topic') return 'Topic';
              if (node.type === 'main') return 'Main Node';
              if (node.type === 'sub') return 'Sub Node';
              if (node.type === 'insight') return 'Insight';
              if (node.type === 'opportunity') return 'Opportunity';
              return 'Node';
            };

            return (
              <div className={`fixed bottom-6 w-[480px] z-[100] shadow-2xl bg-white rounded-lg border border-gray-200 ${isReflectionSidebarOpen ? 'left-[calc(50%-200px)]' : 'left-1/2'} transform -translate-x-1/2`} style={{ pointerEvents: 'auto' }}>
                {/* Header with title and buttons */}
                <div className="flex items-center justify-between p-4 border-b border-gray-200">
                  <div className="flex items-center gap-2">
                    <h3 className="text-lg font-bold text-gray-800">{getNodeTypeLabel(selectedNodeData)}</h3>
                  </div>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => handleEdit(selectedNodeData)}
                      className="p-2 hover:bg-blue-50 rounded transition-colors"
                      title="Edit"
                    >
                      <Edit2 size={18} className="text-blue-600" />
                    </button>
                    <button
                      onClick={() => setSelectedNode(null)}
                      className="p-2 hover:bg-gray-50 rounded transition-colors"
                      title="Close"
                    >
                      <X size={18} className="text-gray-600" />
                    </button>
                  </div>
                </div>

                {/* Node description */}
                <div className="p-4 border-b border-gray-200">
                  <p className="text-gray-700 leading-relaxed whitespace-pre-wrap">
                    {selectedNodeData.description || selectedNodeData.text || ''}
                  </p>
                </div>

                {/* Action buttons */}
                <div className="p-4 flex gap-3">
                  <button
                    onClick={() => {
                      handleAddNodeClick(selectedNodeData);
                    }}
                    className="flex-1 flex items-center justify-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors font-medium"
                  >
                    <Plus size={18} />
                    Add (Human)
                  </button>
                  <button
                    onClick={() => {
                      handleGenerate(selectedNodeData);
                    }}
                    disabled={loading}
                    className="flex-1 flex items-center justify-center gap-2 px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors font-medium"
                  >
                    <Sparkles size={18} />
                    Add (AI)
                  </button>
                </div>
              </div>
            );
          })()}

          {mode === 'exploration' && nodes.length > 0 && (
            <div className={`fixed bottom-6 w-[360px] z-[90] shadow-2xl bg-white rounded-lg ${isReflectionSidebarOpen ? 'right-[400px]' : 'right-6'}`} style={{ pointerEvents: 'auto' }}>
              <div className="bg-white rounded-lg shadow-lg p-4 border border-gray-200">
                <div className="mb-3">
                  <h3 className="text-lg font-bold text-gray-800">Creative Flow Timeline</h3>
                  <p className="text-xs text-gray-600 mt-1">Watch your creativity journey unfold! üé®</p>
                </div>
                <div className="border-t border-dotted border-blue-300 mb-3"></div>

                <div className="relative h-32 bg-gray-50 rounded-lg mb-3 overflow-hidden">
                  <svg className="w-full h-full" viewBox="0 0 200 100" preserveAspectRatio="xMidYMid meet">
                    {/* Background grid lines for better visualization */}
                    <defs>
                      <pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
                        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#e5e7eb" strokeWidth="0.5" opacity="0.5" />
                      </pattern>
                    </defs>
                    <rect x="0" y="0" width="200" height="100" fill="url(#grid)" />

                    {/* Calculate X positions to fill the box */}
                    {(() => {
                      const pointCount = creativityHistory.length;
                      const getXPosition = (index) => {
                        if (pointCount === 0) return 100;
                        if (pointCount === 1) return 100; // Center for single point
                        // For 2+ points, use full width of the rect (0 to 200)
                        // The rect is width="200" height="100", so 0 and 200 are the left and right edges
                        // This wider viewBox (200x100) better matches the container's aspect ratio
                        const minX = 0;
                        const maxX = 200;
                        return minX + (index / (pointCount - 1)) * (maxX - minX);
                      };

                      return (
                        <>
                          {/* Creativity line (green) */}
                          <polyline
                            points={creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const creativity = typeof metrics === 'object' ? metrics.creativity : (typeof metrics === 'number' ? metrics : 0);
                              const y = 90 - (creativity * 80);
                              return `${x},${y}`;
                            }).join(' ')}
                            fill="none"
                            stroke="#10b981"
                            strokeWidth="2.5"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            className="transition-all duration-700 ease-out"
                          />
                          {creativityHistory.map((metrics, index) => {
                            const x = getXPosition(index);
                            const creativity = typeof metrics === 'object' ? metrics.creativity : (typeof metrics === 'number' ? metrics : 0);
                            const y = 90 - (creativity * 80);
                            const isLast = index === creativityHistory.length - 1;
                            return (
                              <g key={`creativity-${index}`} className="transition-all duration-700 ease-out">
                                <circle
                                  cx={x}
                                  cy={y}
                                  r={isLast ? "3.5" : "3.5"}
                                  fill="#10b981"
                                  stroke="white"
                                  strokeWidth="2"
                                  opacity="0.9"
                                  className={isLast ? "animate-pulse" : ""}
                                  style={{
                                    transition: 'all 0.7s cubic-bezier(0.4, 0, 0.2, 1)'
                                  }}
                                >
                                  {isLast && (
                                    <animate
                                      attributeName="r"
                                      values="3.5;5;3.5"
                                      dur="0.6s"
                                      repeatCount="1"
                                    />
                                  )}
                                </circle>
                              </g>
                            );
                          })}

                          {/* Dependency line (orange) */}
                          <polyline
                            points={creativityHistory.map((metrics, index) => {
                              const x = getXPosition(index);
                              const dependency = typeof metrics === 'object' ? metrics.dependency : 0;
                              const y = 90 - (dependency * 80);
                              return `${x},${y}`;
                            }).join(' ')}
                            fill="none"
                            stroke="#f97316"
                            strokeWidth="2.5"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            className="transition-all duration-700 ease-out"
                          />
                          {creativityHistory.map((metrics, index) => {
                            const x = getXPosition(index);
                            const dependency = typeof metrics === 'object' ? metrics.dependency : 0;
                            const y = 90 - (dependency * 80);
                            const isLast = index === creativityHistory.length - 1;
                            return (
                              <g key={`dependency-${index}`} className="transition-all duration-700 ease-out">
                                <circle
                                  cx={x}
                                  cy={y}
                                  r="3.5"
                                  fill="#f97316"
                                  stroke="white"
                                  strokeWidth="2"
                                  opacity="0.9"
                                  className={isLast ? "animate-pulse" : ""}
                                  style={{
                                    transition: 'all 0.7s cubic-bezier(0.4, 0, 0.2, 1)'
                                  }}
                                >
                                  {isLast && (
                                    <animate
                                      attributeName="r"
                                      values="3.5;5;3.5"
                                      dur="0.6s"
                                      begin="0.1s"
                                      repeatCount="1"
                                    />
                                  )}
                                </circle>
                              </g>
                            );
                          })}
                        </>
                      );
                    })()}
                  </svg>
                </div>

                {/* Legend and Metrics */}
                <div className="flex items-center justify-between mt-3 relative">
                  <div className="flex items-center gap-4">
                    <div className="flex items-center gap-2">
                      <div className="w-8 h-1 bg-green-500 rounded"></div>
                      <span className="text-xs text-gray-700">Creativity</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <div className="w-8 h-1 bg-orange-500 rounded"></div>
                      <span className="text-xs text-gray-700">Dependency</span>
                    </div>
                  </div>
                  <div className="flex items-center gap-3">
                    <div className="flex items-center gap-1 text-sm font-semibold text-gray-700">
                      <span className="text-green-500">‚Üë</span>
                      <span>{Math.round(currentCreativity * 100)}%</span>
                    </div>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setCurrentPage('report');
                        setActiveTab('timeline');
                      }}
                      className="text-gray-400 hover:text-gray-600 p-1.5 rounded hover:bg-gray-100 transition-colors"
                      title="View Details"
                    >
                      <Maximize2 size={18} />
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

        </div>

        {/* Reflection Sidebar Toggle Button (when closed) */}
        {!isReflectionSidebarOpen && reflections.length > 0 && (
          <button
            onClick={() => setIsReflectionSidebarOpen(true)}
            className="fixed top-4 right-4 z-50 w-12 h-12 bg-white rounded-lg shadow-lg border-2 border-yellow-300 flex items-center justify-center hover:bg-yellow-50 transition-all hover:scale-105 relative"
            title="Open Reflections"
          >
            <Lightbulb className="text-yellow-600" size={24} />
            {/* Alert badge */}
            <div className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 rounded-full flex items-center justify-center border-2 border-white">
              <AlertCircle size={12} className="text-white" />
            </div>
          </button>
        )}

        {/* Reflection Sidebar */}
        {isReflectionSidebarOpen && (
          <div className="w-96 bg-white border-l border-gray-200 overflow-y-auto p-4 relative flex flex-col">
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center gap-2">
                <Lightbulb className="text-yellow-500" size={24} />
                <h2 className="text-xl font-bold text-gray-800">Reflections</h2>
              </div>
              <button
                onClick={() => setIsReflectionSidebarOpen(false)}
                className="p-1.5 hover:bg-gray-100 rounded transition-colors"
                title="Close Reflections"
              >
                <ChevronRight size={20} className="text-gray-500" />
              </button>
            </div>

            {reflections.length === 0 ? (
              <div className="text-center text-gray-400 mt-8">
                <Lightbulb size={48} className="mx-auto mb-2 opacity-50" />
                <p className="text-sm">Generate ideas to see reflections here</p>
              </div>
            ) : (
              <div className="space-y-3 pb-96">
                {reflections.map(reflection => {
                  const isExpanded = expandedReflectionId === reflection.id;

                  // Get color scheme based on type
                  const getTypeStyle = (type) => {
                    switch (type) {
                      case 'critic':
                        return {
                          bg: 'bg-gradient-to-br from-red-50 to-orange-50',
                          border: 'border-red-200',
                          title: 'Critical Question',
                          titleColor: 'text-red-700'
                        };
                      case 'advice':
                        return {
                          bg: 'bg-gradient-to-br from-blue-50 to-cyan-50',
                          border: 'border-blue-200',
                          title: 'Strategic Advice',
                          titleColor: 'text-blue-700'
                        };
                      default:
                        return {
                          bg: 'bg-gradient-to-br from-yellow-50 to-orange-50',
                          border: 'border-yellow-200',
                          title: 'Reflection',
                          titleColor: 'text-gray-700'
                        };
                    }
                  };

                  const typeStyle = getTypeStyle(reflection.type);

                  return (
                    <div
                      key={reflection.id}
                      onClick={() => handleReflectionClick(reflection.id, reflection.nodeId)}
                      className={`${typeStyle.bg} rounded-lg p-4 shadow-sm border ${typeStyle.border} relative cursor-pointer hover:shadow-md transition-all`}
                    >
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleDeleteReflection(reflection.id);
                        }}
                        className="absolute top-2 right-2 p-1 hover:bg-white rounded transition-colors z-10"
                        title="Delete"
                      >
                        <X size={16} className="text-gray-500" />
                      </button>
                      <div className="pr-6">
                        <div className="flex items-center gap-2 mb-1">
                          <span className={`text-xs font-semibold ${typeStyle.titleColor} uppercase tracking-wide`}>
                            {typeStyle.title}
                          </span>
                        </div>
                        <h3 className="font-semibold text-gray-800 text-sm mb-1">
                          {reflection.title || reflection.topic}
                        </h3>
                      </div>
                      {isExpanded && (
                        <div className="mt-3 pt-3 border-t border-gray-200">
                          <p className="text-sm text-gray-700 leading-relaxed">
                            {reflection.content}
                          </p>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}